{"sql": "SELECT COUNT(*) FROM club", "explanation": "To find the number of clubs, we use the COUNT(*) function which counts all rows in the 'club' table. The 'club' table is identified from the provided schema where 'table_names' includes 'club'. This query will return a single number representing the total number of clubs in the database.", "cost": {"prompt_tokens": 586, "completion_tokens": 86, "total_tokens": 672}}
{"sql": "SELECT COUNT(*) FROM club", "explanation": "The SQL query counts the number of rows in the 'club' table. The COUNT(*) function is used to count all rows, providing the total number of clubs in the database.", "cost": {"prompt_tokens": 586, "completion_tokens": 61, "total_tokens": 647}}
{"sql": "SELECT name FROM club ORDER BY name ASC;", "explanation": "This SQL query selects the 'name' column from the 'club' table and orders the results in ascending alphabetical order using the ORDER BY clause. The 'club' table is identified from the provided schema where 'name' is a column in the 'club' table.", "cost": {"prompt_tokens": 590, "completion_tokens": 82, "total_tokens": 672}}
{"sql": "SELECT name FROM club ORDER BY name ASC;", "explanation": "This SQL query selects the 'name' column from the 'club' table and orders the results alphabetically in ascending order using the ORDER BY clause. The 'club' table is identified from the provided schema where 'name' is a column associated with the 'club' table.", "cost": {"prompt_tokens": 591, "completion_tokens": 84, "total_tokens": 675}}
{"sql": "SELECT club.name AS ClubName, club.manager AS Manager, club.captain AS Captain FROM club;", "explanation": "This SQL query selects the name, manager, and captain from the 'club' table. The 'club' table contains columns for 'name', 'manager', and 'captain', which directly correspond to the required information. The query uses aliases (AS) to make the output columns more readable.", "cost": {"prompt_tokens": 589, "completion_tokens": 100, "total_tokens": 689}}
{"sql": "SELECT club.name AS ClubName, club.manager AS Manager, club.captain AS Captain FROM club;", "explanation": "This SQL query selects the name, manager, and captain from the 'club' table. The 'club' table contains columns for 'name', 'manager', and 'captain', which are directly related to the question's requirement to return the managers and captains of all clubs. The query uses aliases ('ClubName', 'Manager', 'Captain') for better readability of the results.", "cost": {"prompt_tokens": 589, "completion_tokens": 117, "total_tokens": 706}}
{"sql": "SELECT name FROM club WHERE manufacturer != 'Nike';", "explanation": "The query selects the 'name' column from the 'club' table where the 'manufacturer' column is not equal to 'Nike'. This directly addresses the requirement to list clubs whose manufacturer is not 'Nike'.", "cost": {"prompt_tokens": 592, "completion_tokens": 73, "total_tokens": 665}}
{"sql": "SELECT name FROM club WHERE manufacturer != 'Nike';", "explanation": "This SQL query selects the 'name' column from the 'club' table where the 'manufacturer' column is not equal to 'Nike'. It filters out clubs that have Nike as their manufacturer, thus listing only those clubs that do not use Nike.", "cost": {"prompt_tokens": 594, "completion_tokens": 80, "total_tokens": 674}}
{"sql": "SELECT p.name FROM player p ORDER BY p.wins_count ASC", "explanation": "This SQL query selects the 'name' column from the 'player' table and orders the results in ascending order based on the 'wins_count' column. The 'player' table is identified by its index (1) in the 'table_names' list. The 'name' and 'wins_count' columns are identified by their respective indices (9 and 12) in the 'column_names' list.", "cost": {"prompt_tokens": 593, "completion_tokens": 115, "total_tokens": 708}}
{"sql": "SELECT p.name FROM player p ORDER BY p.wins_count ASC", "explanation": "This SQL query selects the 'name' column from the 'player' table and orders the results by the 'wins_count' column in ascending order. The 'player' table is identified by its index (1) in the 'table_names' list. The 'name' and 'wins_count' columns are identified by their respective indices in the 'column_names' list.", "cost": {"prompt_tokens": 594, "completion_tokens": 108, "total_tokens": 702}}
{"sql": "SELECT p.name FROM player p ORDER BY p.earnings DESC LIMIT 1", "explanation": "This SQL query selects the name of the player from the 'player' table, orders the results by the 'earnings' column in descending order to get the highest earnings first, and limits the result to just the top 1 entry. This ensures that the name of the player with the highest earnings is returned.", "cost": {"prompt_tokens": 592, "completion_tokens": 99, "total_tokens": 691}}
{"sql": "SELECT p.name FROM player p ORDER BY p.earnings DESC LIMIT 1", "explanation": "This SQL query selects the name of the player from the 'player' table, orders the results by the 'earnings' column in descending order to get the player with the highest earnings, and limits the result to just the top player using LIMIT 1.", "cost": {"prompt_tokens": 592, "completion_tokens": 88, "total_tokens": 680}}
{"sql": "SELECT DISTINCT country FROM player WHERE earnings > 1200000", "explanation": "This SQL query selects distinct countries from the 'player' table where the 'earnings' column value is greater than 1200000. The 'DISTINCT' keyword ensures that each country appears only once in the result set, even if multiple players from the same country meet the earnings criteria.", "cost": {"prompt_tokens": 596, "completion_tokens": 91, "total_tokens": 687}}
{"sql": "SELECT DISTINCT p.country FROM player p WHERE p.earnings > 1200000", "explanation": "This SQL query selects distinct countries from the 'player' table where the 'earnings' column value is greater than 1200000. The 'DISTINCT' keyword ensures that each country is listed only once, even if multiple players from the same country meet the earnings criteria.", "cost": {"prompt_tokens": 595, "completion_tokens": 93, "total_tokens": 688}}
{"sql": "SELECT p.country FROM player p WHERE p.wins_count > 2 ORDER BY p.earnings DESC LIMIT 1", "explanation": "This SQL query selects the country of the player with the highest earnings among those who have more than 2 win counts. It filters players with `wins_count > 2`, orders them by `earnings` in descending order to get the highest earner at the top, and uses `LIMIT 1` to retrieve only the top player's country.", "cost": {"prompt_tokens": 602, "completion_tokens": 115, "total_tokens": 717}}
{"sql": "SELECT p.country FROM player p WHERE p.wins_count > 2 GROUP BY p.country ORDER BY COUNT(p.player_id) DESC LIMIT 1;", "explanation": "This SQL query selects the country of players who have more than 2 wins. It groups the results by country and orders them by the count of player IDs in descending order, ensuring that the country with the most players who have more than 2 wins is at the top. The LIMIT 1 clause ensures that only the top country is returned.", "cost": {"prompt_tokens": 602, "completion_tokens": 118, "total_tokens": 720}}
{"sql": "SELECT player.name AS player_name, club.name AS club_name FROM player JOIN club ON player.club_id = club.club_id", "explanation": "This SQL query joins the 'player' and 'club' tables on the 'club_id' column to retrieve the names of players and their respective clubs. The SELECT statement specifies the columns to display: 'player.name' as 'player_name' and 'club.name' as 'club_name'. The JOIN operation ensures that only matching records from both tables are included in the result set.", "cost": {"prompt_tokens": 592, "completion_tokens": 121, "total_tokens": 713}}
{"sql": "SELECT player.name AS player_name, club.name AS club_name FROM player JOIN club ON player.club_id = club.club_id", "explanation": "This SQL query retrieves the names of players and their corresponding clubs. It uses an INNER JOIN to combine rows from the 'player' and 'club' tables where the 'club_id' in the 'player' table matches the 'club_id' in the 'club' table. The SELECT statement specifies the columns to return, renaming them to 'player_name' and 'club_name' for clarity.", "cost": {"prompt_tokens": 595, "completion_tokens": 124, "total_tokens": 719}}
{"sql": "SELECT DISTINCT c.name FROM club c JOIN player p ON c.club_id = p.club_id WHERE p.wins_count > 2", "explanation": "This SQL query selects distinct club names from the 'club' table where there are players in the 'player' table with more than 2 win counts. The JOIN operation links the 'club' and 'player' tables via the 'club_id' column. The WHERE clause filters players with 'wins_count' greater than 2, ensuring only clubs with such players are listed.", "cost": {"prompt_tokens": 595, "completion_tokens": 122, "total_tokens": 717}}
{"sql": "SELECT DISTINCT c.name FROM club c JOIN player p ON c.club_id = p.club_id WHERE p.wins_count > 2;", "explanation": "This SQL query selects distinct club names from the 'club' table where there are players in the 'player' table who have a 'wins_count' greater than 2. The JOIN operation links the 'club' and 'player' tables via the 'club_id' column. The DISTINCT keyword ensures that each club name appears only once in the result set.", "cost": {"prompt_tokens": 596, "completion_tokens": 118, "total_tokens": 714}}
{"sql": "SELECT p.name FROM player p JOIN club c ON p.club_id = c.club_id WHERE c.manager = 'Sam Allardyce';", "explanation": "This SQL query retrieves the names of players from the 'player' table who belong to a club managed by 'Sam Allardyce'. It uses an INNER JOIN to connect the 'player' table with the 'club' table via the 'club_id' column. The WHERE clause filters the results to include only clubs where the manager is 'Sam Allardyce'.", "cost": {"prompt_tokens": 595, "completion_tokens": 121, "total_tokens": 716}}
{"sql": "SELECT p.name FROM player p JOIN club c ON p.club_id = c.club_id WHERE c.manager = 'Sam Allardyce';", "explanation": "This SQL query joins the 'player' and 'club' tables on the 'club_id' column to find players whose club is managed by 'Sam Allardyce'. It selects the names of these players.", "cost": {"prompt_tokens": 596, "completion_tokens": 89, "total_tokens": 685}}
{"sql": "SELECT c.name FROM club c JOIN player p ON c.club_id = p.club_id GROUP BY c.name ORDER BY AVG(p.earnings) DESC", "explanation": "This SQL query joins the 'club' and 'player' tables on the 'club_id' column. It then groups the results by the club's name and orders them in descending order based on the average earnings of the players belonging to each club. The SELECT statement retrieves the names of the clubs.", "cost": {"prompt_tokens": 594, "completion_tokens": 110, "total_tokens": 704}}
{"sql": "SELECT c.name AS club_name, AVG(p.earnings) AS avg_earnings FROM club c JOIN player p ON c.club_id = p.club_id GROUP BY c.name ORDER BY avg_earnings DESC", "explanation": "This SQL query joins the 'club' and 'player' tables on the 'club_id' column. It then groups the results by the club's name and calculates the average earnings of players in each club. Finally, it orders the results in descending order based on the average earnings, providing the names of clubs with the highest average player earnings at the top.", "cost": {"prompt_tokens": 598, "completion_tokens": 135, "total_tokens": 733}}
{"sql": "SELECT manufacturer, COUNT(DISTINCT club_id) AS club_count FROM club GROUP BY manufacturer;", "explanation": "This SQL query selects the 'manufacturer' column from the 'club' table and counts the distinct 'club_id' associated with each manufacturer. The COUNT(DISTINCT club_id) ensures that each club is counted only once per manufacturer. The GROUP BY clause groups the results by manufacturer, allowing the count to be calculated for each unique manufacturer.", "cost": {"prompt_tokens": 593, "completion_tokens": 106, "total_tokens": 699}}
{"sql": "SELECT manufacturer, COUNT(*) AS club_count FROM club GROUP BY manufacturer", "explanation": "This SQL query counts the number of clubs that use each manufacturer. It selects the 'manufacturer' column from the 'club' table and uses the COUNT(*) function to count the number of occurrences for each manufacturer. The GROUP BY clause groups the results by the 'manufacturer' column, ensuring that the count is calculated for each unique manufacturer.", "cost": {"prompt_tokens": 587, "completion_tokens": 100, "total_tokens": 687}}
{"sql": "SELECT `manufacturer`, COUNT(*) AS `count` FROM `club` GROUP BY `manufacturer` ORDER BY `count` DESC LIMIT 1;", "explanation": "This SQL query selects the `manufacturer` column from the `club` table, counts the occurrences of each manufacturer, and groups the results by manufacturer. It then orders the results in descending order based on the count and limits the output to the most common manufacturer. This helps identify the manufacturer with the highest number of clubs.", "cost": {"prompt_tokens": 589, "completion_tokens": 112, "total_tokens": 701}}
{"sql": "SELECT manufacturer, COUNT(*) AS count FROM club GROUP BY manufacturer ORDER BY count DESC LIMIT 1;", "explanation": "This SQL query selects the 'manufacturer' column from the 'club' table and counts the occurrences of each manufacturer. It groups the results by 'manufacturer' and orders them in descending order based on the count. The 'LIMIT 1' clause ensures that only the most common manufacturer is returned.", "cost": {"prompt_tokens": 588, "completion_tokens": 98, "total_tokens": 686}}
{"sql": "SELECT manufacturer FROM club GROUP BY manufacturer HAVING COUNT(*) > 1", "explanation": "This SQL query selects the 'manufacturer' column from the 'club' table, groups the results by 'manufacturer', and filters to include only those manufacturers that are associated with more than one club, as indicated by the COUNT(*) > 1 condition.", "cost": {"prompt_tokens": 592, "completion_tokens": 84, "total_tokens": 676}}
{"sql": "SELECT Manufacturer, COUNT(DISTINCT Club_ID) AS ClubCount FROM club GROUP BY Manufacturer HAVING ClubCount > 1", "explanation": "This SQL query selects the 'Manufacturer' and counts the distinct 'Club_ID' for each manufacturer from the 'club' table. It groups the results by 'Manufacturer' and filters to include only those manufacturers associated with more than one club, indicating they work for more than one club.", "cost": {"prompt_tokens": 590, "completion_tokens": 102, "total_tokens": 692}}
{"sql": "SELECT country FROM player GROUP BY country HAVING COUNT(player_id) > 1", "explanation": "This SQL query selects the 'country' column from the 'player' table, groups the results by 'country', and uses the HAVING clause to filter out countries that have more than one player, as indicated by COUNT(player_id) > 1.", "cost": {"prompt_tokens": 590, "completion_tokens": 87, "total_tokens": 677}}
{"sql": "SELECT country FROM player GROUP BY country HAVING COUNT(player_id) > 1", "explanation": "This SQL query selects the 'country' column from the 'player' table, groups the results by 'country', and uses the HAVING clause to filter out countries that have produced more than one player, as indicated by a count of 'player_id' greater than 1.", "cost": {"prompt_tokens": 589, "completion_tokens": 92, "total_tokens": 681}}
{"sql": "SELECT c.name FROM club c LEFT JOIN player p ON c.club_id = p.club_id WHERE p.player_id IS NULL", "explanation": "This SQL query selects the names of clubs that do not have any players. It uses a LEFT JOIN to combine the 'club' and 'player' tables based on the 'club_id' column. The WHERE clause filters out rows where 'player_id' is NULL, indicating that there are no players associated with those clubs.", "cost": {"prompt_tokens": 591, "completion_tokens": 109, "total_tokens": 700}}
{"sql": "SELECT c.name FROM club c LEFT JOIN player p ON c.club_id = p.club_id WHERE p.player_id IS NULL", "explanation": "This SQL query selects the names of clubs from the 'club' table and performs a left join with the 'player' table on the 'club_id' column. The WHERE clause filters out rows where there is no corresponding 'player_id' in the 'player' table, indicating that the club has no players.", "cost": {"prompt_tokens": 593, "completion_tokens": 107, "total_tokens": 700}}
{"sql": "SELECT DISTINCT country FROM player WHERE earnings > 1400000 OR earnings < 1100000;", "explanation": "This SQL query selects unique countries from the 'player' table where players have earnings either greater than 1,400,000 or less than 1,100,000. The DISTINCT keyword ensures each country is listed only once, avoiding duplicates.", "cost": {"prompt_tokens": 604, "completion_tokens": 88, "total_tokens": 692}}
{"sql": "SELECT DISTINCT p1.country FROM player p1 JOIN player p2 ON p1.country = p2.country WHERE p1.earnings > 1400000 AND p2.earnings < 1100000", "explanation": "This SQL query selects distinct countries from the 'player' table where there are players with earnings over 1400000 and players with earnings below 1100000. It uses a self-join on the 'player' table to compare earnings of players from the same country, ensuring that both conditions are met for the same country.", "cost": {"prompt_tokens": 603, "completion_tokens": 129, "total_tokens": 732}}
{"sql": "SELECT COUNT(DISTINCT country) FROM player", "explanation": "The query selects the count of distinct values in the 'country' column from the 'player' table. This will give the number of unique countries represented by all players in the database.", "cost": {"prompt_tokens": 591, "completion_tokens": 66, "total_tokens": 657}}
{"sql": "SELECT COUNT(DISTINCT country) FROM player", "explanation": "The query counts the number of unique countries from which players originate. It uses the `COUNT(DISTINCT country)` function to ensure each country is counted only once, targeting the 'country' column in the 'player' table.", "cost": {"prompt_tokens": 588, "completion_tokens": 75, "total_tokens": 663}}
{"sql": "SELECT p.name, p.earnings FROM player p WHERE p.country IN ('Australia', 'Zimbabwe')", "explanation": "This SQL query selects the name and earnings of players from the 'player' table where the country is either 'Australia' or 'Zimbabwe'. The 'IN' clause is used to specify multiple values in the WHERE condition, making the query concise and efficient for filtering based on multiple countries.", "cost": {"prompt_tokens": 595, "completion_tokens": 100, "total_tokens": 695}}
{"sql": "SELECT SUM(earnings) AS total_earnings FROM player WHERE country IN ('Australia', 'Zimbabwe')", "explanation": "This SQL query calculates the total earnings of players from either Australia or Zimbabwe. It uses the `SUM` aggregate function on the `earnings` column from the `player` table, filtering the results with the `WHERE` clause to include only players whose `country` is either 'Australia' or 'Zimbabwe'. The result is aliased as `total_earnings` for clarity.", "cost": {"prompt_tokens": 596, "completion_tokens": 122, "total_tokens": 718}}
{"sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id HAVING COUNT(DISTINCT o.order_id) > 2 AND COUNT(oi.order_item_id) >= 3", "explanation": "This SQL query selects the customer ID, first name, and last name from the 'customers' table. It joins the 'orders' table to count the number of distinct orders per customer and the 'order_items' table to count the number of items bought. The GROUP BY clause groups the results by customer ID, and the HAVING clause filters out customers who have placed more than 2 orders and bought at least 3 items.", "cost": {"prompt_tokens": 1214, "completion_tokens": 176, "total_tokens": 1390}}
{"sql": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id HAVING COUNT(DISTINCT o.order_id) > 2 AND COUNT(oi.order_item_id) >= 3", "explanation": "This SQL query selects the customer ID, first name, and last name from the 'customers' table. It joins the 'orders' table to count the number of distinct orders per customer and the 'order_items' table to count the number of items ordered. The GROUP BY clause groups the results by customer ID, and the HAVING clause filters out customers who have ordered more than twice and have bought at least 3 items.", "cost": {"prompt_tokens": 1211, "completion_tokens": 175, "total_tokens": 1386}}
{"sql": "SELECT o.order_id, o.order_status_code, COUNT(oi.product_id) AS product_count FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id, o.order_status_code;", "explanation": "This SQL query joins the 'orders' and 'order_items' tables on the 'order_id' column to count the number of products associated with each order. It selects the 'order_id' and 'order_status_code' from the 'orders' table and counts the 'product_id' from the 'order_items' table, grouping the results by 'order_id' and 'order_status_code' to ensure each order is listed once with its respective product count.", "cost": {"prompt_tokens": 1210, "completion_tokens": 157, "total_tokens": 1367}}
{"sql": "SELECT o.order_id, COUNT(oi.product_id) AS product_count, o.order_status_code FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id, o.order_status_code;", "explanation": "This SQL query joins the 'orders' and 'order_items' tables on the 'order_id' column to count the number of products in each order. It selects the 'order_id', the count of 'product_id' as 'product_count', and the 'order_status_code' from the 'orders' table. The GROUP BY clause groups the results by 'order_id' and 'order_status_code' to ensure accurate counts for each order.", "cost": {"prompt_tokens": 1205, "completion_tokens": 154, "total_tokens": 1359}}
{"sql": "SELECT DISTINCT o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id WHERE o.date_order_placed = (SELECT MIN(date_order_placed) FROM orders) OR (SELECT COUNT(*) FROM order_items WHERE order_id = o.order_id) > 1;", "explanation": "This SQL query selects distinct dates of orders that either were placed at the earliest time or have more than 1 item. It uses a subquery to find the earliest order date and another subquery to count items per order, joining the 'orders' and 'order_items' tables to filter the required orders.", "cost": {"prompt_tokens": 1205, "completion_tokens": 141, "total_tokens": 1346}}
{"sql": "SELECT MIN(o.date_order_placed) AS earliest_order_date, o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id HAVING COUNT(oi.order_item_id) > 1;", "explanation": "This SQL query retrieves the date of the earliest order and the dates of all orders with more than one item. It joins the 'orders' and 'order_items' tables on the 'order_id' column, groups the results by 'order_id', and uses the HAVING clause to filter groups with more than one item. The MIN function is used to find the earliest order date.", "cost": {"prompt_tokens": 1205, "completion_tokens": 147, "total_tokens": 1352}}
{"sql": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_id IS NULL;", "explanation": "This SQL query selects the first name, middle initial, and last name from the 'customers' table. It uses a LEFT JOIN with the 'orders' table on the 'customer_id' column to find all customers. The WHERE clause filters out customers who have made orders by checking for NULL 'order_id' in the 'orders' table, thus listing only those customers who did not make any orders.", "cost": {"prompt_tokens": 1203, "completion_tokens": 137, "total_tokens": 1340}}
{"sql": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_id IS NULL;", "explanation": "This SQL query selects the first name, middle initial, and last name of customers from the 'customers' table. It uses a LEFT JOIN with the 'orders' table to find all customers who have no corresponding entries in the 'orders' table, indicating they have not made any orders. The condition 'o.order_id IS NULL' ensures that only customers without orders are included in the results.", "cost": {"prompt_tokens": 1206, "completion_tokens": 135, "total_tokens": 1341}}
{"sql": "SELECT p.product_id, p.product_name, p.product_price, p.product_color FROM products p WHERE (SELECT COUNT(*) FROM order_items oi WHERE oi.product_id = p.product_id) < 2;", "explanation": "This SQL query selects the id, name, price, and color of products from the 'products' table. It uses a subquery to count the number of times each product appears in the 'order_items' table. The main query filters out products that have been ordered fewer than twice, ensuring only those with zero or one order are included.", "cost": {"prompt_tokens": 1207, "completion_tokens": 129, "total_tokens": 1336}}
{"sql": "SELECT p.product_id, p.product_name, p.product_price, p.product_color FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id HAVING COUNT(oi.order_id) < 2", "explanation": "This SQL query selects the product ID, name, price, and color from the 'products' table. It joins the 'order_items' table to count the number of orders each product appears in. The 'GROUP BY' clause groups the results by product ID, and the 'HAVING' clause filters out products that appear in two or more orders, ensuring only products listed in less than two orders are included.", "cost": {"prompt_tokens": 1208, "completion_tokens": 150, "total_tokens": 1358}}
{"sql": "SELECT o.order_id, o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id HAVING COUNT(oi.product_id) >= 2", "explanation": "This SQL query selects the order ID and date from the 'orders' table. It joins the 'order_items' table to count the number of products per order. The GROUP BY clause groups the results by order ID, and the HAVING clause filters out orders with fewer than 2 products.", "cost": {"prompt_tokens": 1202, "completion_tokens": 120, "total_tokens": 1322}}
{"sql": "SELECT o.order_id, o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id HAVING COUNT(oi.product_id) >= 2", "explanation": "This SQL query retrieves the order IDs and their corresponding dates from the 'orders' table where each order has at least two products. It achieves this by joining the 'orders' table with the 'order_items' table on the 'order_id' column, grouping the results by 'order_id', and using the HAVING clause to filter groups that have a count of 'product_id' greater than or equal to 2.", "cost": {"prompt_tokens": 1199, "completion_tokens": 146, "total_tokens": 1345}}
{"sql": "SELECT p.product_id, p.product_name, p.product_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id ORDER BY COUNT(oi.order_item_id) DESC LIMIT 1;", "explanation": "This SQL query joins the 'products' and 'order_items' tables on the 'product_id' column to count how frequently each product appears in orders. It groups the results by 'product_id' and orders them by the count of 'order_item_id' in descending order, selecting the top product with the highest frequency. The query returns the 'product_id', 'product_name', and 'product_price' of the most frequently ordered product.", "cost": {"prompt_tokens": 1202, "completion_tokens": 154, "total_tokens": 1356}}
{"sql": "SELECT p.product_id, p.product_name, p.product_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id ORDER BY COUNT(oi.order_item_id) DESC LIMIT 1;", "explanation": "This SQL query retrieves the IDs, names, and prices of the most frequently ordered products. It joins the 'products' table with the 'order_items' table on the product ID, groups the results by product ID, and orders them by the count of order items in descending order. The 'LIMIT 1' ensures only the most frequently ordered product is returned.", "cost": {"prompt_tokens": 1202, "completion_tokens": 138, "total_tokens": 1340}}
{"sql": "SELECT o.order_id, SUM(p.product_price) AS total_price FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id ORDER BY total_price ASC LIMIT 1", "explanation": "This SQL query joins the 'orders', 'order_items', and 'products' tables to calculate the sum of product prices for each order. It groups the results by 'order_id' and orders them by the total price in ascending order. The 'LIMIT 1' clause ensures that only the order with the least sum of product prices is returned, along with its 'order_id' and the corresponding sum.", "cost": {"prompt_tokens": 1202, "completion_tokens": 154, "total_tokens": 1356}}
{"sql": "SELECT o.order_id, SUM(p.product_price) AS total_cost FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id ORDER BY total_cost ASC LIMIT 1;", "explanation": "This SQL query finds the order with the least total cost by joining the 'orders', 'order_items', and 'products' tables. It calculates the total cost for each order by summing the 'product_price' of all items in the order. The results are grouped by 'order_id' and sorted in ascending order of 'total_cost'. The 'LIMIT 1' clause ensures that only the order with the lowest total cost is returned.", "cost": {"prompt_tokens": 1202, "completion_tokens": 161, "total_tokens": 1363}}
{"sql": "SELECT `payment method code`, COUNT(*) AS count FROM `customer payment methods` GROUP BY `payment method code` ORDER BY count DESC LIMIT 1;", "explanation": "This SQL query identifies the most popular payment method by counting the occurrences of each `payment method code` in the `customer payment methods` table. It groups the results by `payment method code`, orders them in descending order based on the count, and limits the result to the top one.", "cost": {"prompt_tokens": 1192, "completion_tokens": 108, "total_tokens": 1300}}
{"sql": "SELECT `payment method code`, COUNT(*) AS usage_count FROM `customer payment methods` GROUP BY `payment method code` ORDER BY usage_count DESC LIMIT 1;", "explanation": "This SQL query retrieves the most frequently used payment method by customers. It selects the `payment method code` from the `customer payment methods` table, counts the occurrences of each payment method, and orders the results in descending order based on the count. The `LIMIT 1` clause ensures that only the most used payment method is returned.", "cost": {"prompt_tokens": 1194, "completion_tokens": 120, "total_tokens": 1314}}
{"sql": "SELECT c.gender_code, COUNT(DISTINCT o.product_id) AS number_of_products           FROM customers c           JOIN orders o ON c.customer_id = o.customer_id           JOIN order_items oi ON o.order_id = oi.order_id           GROUP BY c.gender_code;", "explanation": "This SQL query joins the 'customers', 'orders', and 'order_items' tables to count the number of unique products each gender of customers buys. The 'gender_code' from the 'customers' table is selected, and the count of distinct 'product_id' from the 'order_items' table is calculated for each gender. The results are grouped by 'gender_code' to get the count per gender.", "cost": {"prompt_tokens": 1202, "completion_tokens": 158, "total_tokens": 1360}}
{"sql": "SELECT c.gender_code, COUNT(DISTINCT p.product_id) AS product_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY c.gender_code", "explanation": "This SQL query joins the 'customers', 'orders', 'order_items', and 'products' tables to count the unique products bought by each gender. The 'GROUP BY' clause ensures the count is aggregated by gender code.", "cost": {"prompt_tokens": 1192, "completion_tokens": 123, "total_tokens": 1315}}
{"sql": "SELECT c.gender_code, COUNT(o.order_id) AS order_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.gender_code", "explanation": "This SQL query joins the 'customers' and 'orders' tables on the 'customer_id' column to count the number of orders placed by each gender. The 'SELECT' statement retrieves the 'gender_code' from the 'customers' table and counts the 'order_id' from the 'orders' table, grouping the results by 'gender_code' to get the order count for each gender.", "cost": {"prompt_tokens": 1194, "completion_tokens": 131, "total_tokens": 1325}}
{"sql": "SELECT c.gender_code, COUNT(o.order_id) AS order_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.gender_code", "explanation": "This SQL query joins the 'customers' and 'orders' tables on the 'customer_id' column to count the number of orders placed by each gender. The 'gender_code' column from the 'customers' table is selected, and the COUNT function is used to count the 'order_id' from the 'orders' table. The results are grouped by 'gender_code' to get the order count for each gender.", "cost": {"prompt_tokens": 1192, "completion_tokens": 136, "total_tokens": 1328}}
{"sql": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name, pm.payment_method_code FROM customers c JOIN customer_payment_methods pm ON c.customer_id = pm.customer_id;", "explanation": "The SQL query joins the 'customers' table with the 'customer_payment_methods' table using the 'customer_id' column to retrieve the first name, middle initial, last name from the 'customers' table and the payment method code from the 'customer_payment_methods' table. This ensures that we list the required customer details along with their payment methods.", "cost": {"prompt_tokens": 1200, "completion_tokens": 126, "total_tokens": 1326}}
{"sql": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name, p.payment_method_code FROM customers c JOIN customer_payment_methods p ON c.customer_id = p.customer_id", "explanation": "The SQL query selects the first name, middle initial, and last name from the 'customers' table and the payment method code from the 'customer_payment_methods' table. It uses an INNER JOIN to combine rows from both tables where the customer IDs match, ensuring that only customers with payment methods are included in the results.", "cost": {"prompt_tokens": 1203, "completion_tokens": 120, "total_tokens": 1323}}
{"sql": "SELECT invoices.invoice_status_code, invoices.invoice_date, shipments.shipment_date FROM invoices JOIN shipments ON invoices.invoice_number = shipments.invoice_number;", "explanation": "The query selects the invoice status, invoice date, and shipment date by joining the 'invoices' and 'shipments' tables on the 'invoice_number' column. This ensures that the dates and statuses are correctly matched for each invoice.", "cost": {"prompt_tokens": 1197, "completion_tokens": 93, "total_tokens": 1290}}
{"sql": "SELECT i.invoice_status_code, i.invoice_date, s.shipment_date FROM invoices i LEFT JOIN shipments s ON i.invoice_number = s.invoice_number;", "explanation": "This SQL query selects the invoice status code, invoice date, and shipment date from the 'invoices' and 'shipments' tables. It uses a LEFT JOIN to ensure all invoices are included even if they don't have a corresponding shipment. The join condition is based on the invoice number, which is a common field in both tables.", "cost": {"prompt_tokens": 1198, "completion_tokens": 116, "total_tokens": 1314}}
{"sql": "SELECT p.product_name, s.shipment_date FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id", "explanation": "This SQL query retrieves the product names and shipment dates by joining three tables: 'products', 'order_items', and 'shipments'. The 'products' table provides the product names, the 'order_items' table links products to orders, and the 'shipments' table provides the shipment dates. The joins ensure that only products that are part of an order and have a corresponding shipment are listed.", "cost": {"prompt_tokens": 1198, "completion_tokens": 135, "total_tokens": 1333}}
{"sql": "SELECT p.product_name, s.shipment_date FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL;", "explanation": "This SQL query retrieves the names of products that have been shipped and the corresponding shipment dates. It joins the 'products' table with the 'order_items' table on the 'product_id' to find which products are in orders, and then joins the 'shipments' table on the 'order_id' to filter only those orders that have been shipped. The WHERE clause ensures that only records with a non-null shipment date are included, indicating that the product has indeed been shipped.", "cost": {"prompt_tokens": 1205, "completion_tokens": 159, "total_tokens": 1364}}
{"sql": "SELECT o.order_status_code, s.shipment_tracking_number FROM orders o JOIN shipments s ON o.order_id = s.order_id WHERE o.order_status_code = 'shipped';", "explanation": "This SQL query retrieves the order status code and shipment tracking number for items that are being ordered and shipped. It joins the 'orders' table with the 'shipments' table on the 'order_id' column to link orders with their corresponding shipments. The WHERE clause filters the results to include only those orders with a status code of 'shipped'.", "cost": {"prompt_tokens": 1203, "completion_tokens": 126, "total_tokens": 1329}}
{"sql": "SELECT o.order_status_code, s.shipment_tracking_number FROM orders o JOIN shipments s ON o.order_id = s.order_id WHERE o.order_status_code = 'shipped';", "explanation": "This SQL query retrieves the order status code and shipment tracking number for items that have been ordered and shipped. It joins the 'orders' and 'shipments' tables on the 'order_id' column, filtering to include only rows where the 'order_status_code' is 'shipped'. This ensures that the results include only those items that meet the specified criteria.", "cost": {"prompt_tokens": 1207, "completion_tokens": 128, "total_tokens": 1335}}
{"sql": "SELECT p.product_name, p.product_color FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL", "explanation": "This SQL query retrieves the product name and color from the 'products' table. It joins the 'order_items' table to link products with their respective orders, and then joins the 'shipments' table to filter only those orders that have been shipped (i.e., where 'shipment_date' is not null). This ensures that the results include only the ordered items that have been shipped.", "cost": {"prompt_tokens": 1201, "completion_tokens": 140, "total_tokens": 1341}}
{"sql": "SELECT p.product_name, p.product_color FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL;", "explanation": "This SQL query retrieves the names and colors of all products that have been shipped. It joins the 'products' table with the 'order_items' table on the 'product_id' to find which products are in orders. Then, it joins the resulting table with the 'shipments' table on the 'order_id' to filter out only those products that have a shipment record (i.e., 'shipment_date' is not null).", "cost": {"prompt_tokens": 1198, "completion_tokens": 150, "total_tokens": 1348}}
{"sql": "SELECT DISTINCT p.product_name, p.product_price, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN customers c ON o.customer_id = c.customer_id WHERE c.gender_code = 'F'", "explanation": "This SQL query retrieves distinct product names, prices, and descriptions for products bought by female customers. It joins the 'products', 'order_items', and 'orders' tables to link products with orders, and then joins the 'customers' table to filter by gender code 'F' for females. The DISTINCT keyword ensures unique product entries.", "cost": {"prompt_tokens": 1201, "completion_tokens": 144, "total_tokens": 1345}}
{"sql": "SELECT DISTINCT p.product_name, p.product_price, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN customers c ON o.customer_id = c.customer_id WHERE c.gender_code = 'F'", "explanation": "This SQL query retrieves distinct product names, prices, and descriptions for products bought by female customers. It joins the 'products', 'order_items', and 'orders' tables to link products with orders, and then joins the 'customers' table to filter by gender code 'F' for females. The DISTINCT keyword ensures unique product details are returned.", "cost": {"prompt_tokens": 1202, "completion_tokens": 146, "total_tokens": 1348}}
{"sql": "SELECT i.invoice_status_code FROM invoices i JOIN orders o ON i.invoice_number = o.invoice_number WHERE o.order_status_code != 'Shipped';", "explanation": "This SQL query selects the invoice status code from the 'invoices' table for all orders that have not been shipped. It joins the 'invoices' table with the 'orders' table using the invoice number as the key. The WHERE clause filters out orders that have a status code indicating they have been shipped.", "cost": {"prompt_tokens": 1198, "completion_tokens": 110, "total_tokens": 1308}}
{"sql": "SELECT DISTINCT i.invoice_status_code FROM invoices i JOIN orders o ON i.invoice_number = o.invoice_number WHERE o.order_status_code != 'Shipped'", "explanation": "This SQL query selects distinct invoice statuses from the 'invoices' table for orders that have not been shipped yet. It joins the 'invoices' table with the 'orders' table on the invoice number and filters out orders with a status code of 'Shipped'.", "cost": {"prompt_tokens": 1201, "completion_tokens": 102, "total_tokens": 1303}}
{"sql": "SELECT o.order_id, o.date_order_placed, SUM(p.product_price * oi.quantity) AS total_cost FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id, o.date_order_placed", "explanation": "This SQL query retrieves the order ID and date from the 'orders' table, and calculates the total cost by summing the product of product price and quantity from the 'order_items' table. It joins 'orders' with 'order_items' on order ID and 'order_items' with 'products' on product ID, then groups the results by order ID and date to get the total cost per order."}
{"sql": "SELECT o.order_id, o.date_order_placed, SUM(p.product_price * oi.quantity) AS total_amount_paid FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id", "explanation": "The SQL query selects the order ID and date from the 'orders' table, calculates the total amount paid by summing the product of product price and quantity from the 'products' and 'order_items' tables, and groups the results by order ID."}
{"sql": "SELECT COUNT(DISTINCT o.customer_id) FROM orders o", "explanation": "This SQL query counts the number of unique customer IDs in the 'orders' table. The DISTINCT keyword ensures that each customer is counted only once, even if they have placed multiple orders. This gives the total number of customers who have placed at least one order."}
{"sql": "SELECT COUNT(DISTINCT o.customer_id) FROM orders o", "explanation": "To find the number of different customers who have ordered things, we use the COUNT(DISTINCT) function on the customer_id column from the orders table. This ensures that each customer is counted only once, even if they have placed multiple orders."}
{"sql": "SELECT COUNT(DISTINCT order_item_status_code) FROM order_items", "explanation": "To find the number of unique item states in the orders, we use the COUNT(DISTINCT) function on the 'order_item_status_code' column from the 'order_items' table. This SQL query will return the count of distinct item states, providing the desired information."}
{"sql": "SELECT COUNT(DISTINCT \"order item status code\") FROM \"order items\"", "explanation": "This SQL query counts the number of unique 'order item status code' values in the 'order items' table. The DISTINCT keyword ensures that each status code is counted only once, and the COUNT function tallies the total number of unique codes."}
{"sql": "SELECT COUNT(DISTINCT payment_method_code) FROM customer_payment_methods", "explanation": "To find the number of different payment methods, we use the COUNT function with the DISTINCT keyword to count unique values in the 'payment_method_code' column from the 'customer_payment_methods' table."}
{"sql": "SELECT COUNT(DISTINCT payment_method_code) FROM customer_payment_methods", "explanation": "To find the number of different payment methods customers can choose from, we use the COUNT function with the DISTINCT keyword to count unique values in the 'payment_method_code' column from the 'customer_payment_methods' table."}
{"sql": "SELECT login_name, login_password FROM customers WHERE phone_number LIKE '+12%'", "explanation": "This SQL query selects the login names and passwords from the 'customers' table where the phone number starts with '+12'. The 'LIKE' operator is used with the pattern '+12%' to match any phone number that begins with '+12'."}
{"sql": "SELECT login_name, login_password FROM customers WHERE phone_number LIKE '+12%'", "explanation": "This SQL query selects the 'login_name' and 'login_password' columns from the 'customers' table. The WHERE clause filters the results to include only those rows where the 'phone_number' column starts with '+12'. The '%' symbol is a wildcard that matches any sequence of characters following '+12'."}
{"sql": "SELECT DISTINCT `product size` FROM `products` WHERE `product name` LIKE '%Dell%';", "explanation": "This SQL query selects the distinct product sizes from the 'products' table where the 'product name' column contains the substring 'Dell'. The 'LIKE' operator is used with the pattern '%Dell%' to match any product name that includes 'Dell' anywhere in the string. The 'DISTINCT' keyword ensures that only unique sizes are returned, avoiding duplicates."}
{"sql": "SELECT DISTINCT `product size` FROM `products` WHERE `product name` LIKE '%Dell%';", "explanation": "This SQL query selects the distinct sizes of products from the 'products' table where the product name includes the word 'Dell'. The 'LIKE' operator is used with the pattern '%Dell%' to match any product name containing 'Dell' anywhere in the string. The 'DISTINCT' keyword ensures that each size is listed only once, even if multiple products have the same size."}
{"sql": "SELECT product_price, product_size FROM products WHERE product_price > (SELECT AVG(product_price) FROM products)", "explanation": "This SQL query selects the 'product_price' and 'product_size' columns from the 'products' table. It filters the results to include only those products whose 'product_price' is greater than the average product price calculated from the same 'products' table. The subquery (SELECT AVG(product_price) FROM products) computes the average price, and the main query compares each product's price against this average."}
{"sql": "SELECT product_price, product_size FROM products WHERE product_price > (SELECT AVG(product_price) FROM products)", "explanation": "This SQL query selects the 'product_price' and 'product_size' columns from the 'products' table. It filters the results to include only those rows where the 'product_price' is greater than the average 'product_price' of all products in the table. The subquery (SELECT AVG(product_price) FROM products) calculates the mean price of all products, which is then used in the main query to filter the results."}
{"sql": "SELECT COUNT(*) FROM products WHERE product_id NOT IN (SELECT product_id FROM order_items)", "explanation": "This SQL query counts the number of products that have not been sold. It does this by selecting the count of all product IDs from the 'products' table that are not present in the 'product_id' column of the 'order_items' table. This indicates that these products have not been included in any orders, hence not sold."}
{"sql": "SELECT COUNT(*) FROM products WHERE product_id NOT IN (SELECT product_id FROM order_items)", "explanation": "This SQL query counts the number of products that have not been ordered yet. It does this by selecting the count of all product IDs from the 'products' table where the product ID is not found in the 'product_id' column of the 'order_items' table. This effectively filters out all products that have been included in any order, leaving only those that have not been ordered."}
{"sql": "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer payment methods)", "explanation": "This SQL query counts the number of customers who do not have any payment method. It first selects all customer IDs from the 'customers' table and then excludes those who have a corresponding entry in the 'customer payment methods' table."}
{"sql": "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer_payment_methods)", "explanation": "This SQL query counts the number of customers who do not have a listed payment method. It first selects all customer IDs from the 'customers' table, then filters out those who have a corresponding entry in the 'customer_payment_methods' table, ensuring only customers without a payment method are counted."}
{"sql": "SELECT DISTINCT order_status_code, date_order_placed FROM orders;", "explanation": "The SQL query selects distinct values of 'order_status_code' and 'date_order_placed' from the 'orders' table. This ensures that all unique order statuses and their corresponding dates are retrieved, providing a comprehensive list of order statuses and the dates on which orders were placed."}
{"sql": "SELECT order_status_code, date_order_placed FROM orders;", "explanation": "The query selects the 'order_status_code' and 'date_order_placed' columns from the 'orders' table. These columns correspond to the status codes and dates placed for all orders, respectively. The schema indicates that the 'orders' table contains these relevant columns, making this a straightforward SELECT query to retrieve the desired information."}
{"sql": "SELECT address_line_1, town_city, county FROM customers WHERE country = 'USA';", "explanation": "The SQL query selects the columns 'address_line_1', 'town_city', and 'county' from the 'customers' table. The WHERE clause filters the results to include only those rows where the 'country' column equals 'USA', thus listing the address, town, and county information of customers who live in the USA."}
{"sql": "SELECT address_line_1, town_city, county FROM customers WHERE country = 'United States';", "explanation": "This SQL query selects the columns 'address_line_1', 'town_city', and 'county' from the 'customers' table. The WHERE clause filters the results to include only those rows where the 'country' column is 'United States'. This ensures that the addresses, towns, and county information returned are for customers who live in the United States."}
{"sql": "SELECT c.customer_first_name, p.product_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id;", "explanation": "This SQL query joins four tables: 'customers', 'orders', 'order_items', and 'products'. It selects the first name of the buyer from the 'customers' table and the product name from the 'products' table. The joins ensure that only relevant pairs of buyers and products are listed, based on the relationships defined by foreign keys in the schema."}
{"sql": "SELECT c.customer_first_name, p.product_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id;", "explanation": "This SQL query retrieves the first names of all buyers and the products they bought. It joins the 'customers', 'orders', 'order_items', and 'products' tables to link buyers with their purchased products. The 'JOIN' clauses ensure the correct relationships between tables based on foreign keys, and the 'SELECT' statement specifies the columns to display: 'customer_first_name' from the 'customers' table and 'product_name' from the 'products' table."}
{"sql": "SELECT COUNT(*) FROM `shipment items`", "explanation": "To find the number of items shipped, we count the records in the 'shipment items' table. Each record in this table represents an item that has been shipped, so counting all records gives the total number of shipped items."}
{"sql": "SELECT COUNT(DISTINCT p.product_id) FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL", "explanation": "This SQL query counts the number of unique products that have been shipped. It joins the 'products' table with the 'order_items' table on the product ID, and then joins the resulting table with the 'shipments' table on the order ID. The query filters for records where the shipment date is not null, indicating that the product has been shipped, and then counts the distinct product IDs to avoid duplicates."}
{"sql": "SELECT AVG(product_price) AS average_price FROM products", "explanation": "This SQL query calculates the average price of products by using the AVG function on the 'product_price' column from the 'products' table. The result is aliased as 'average_price' for clarity."}
{"sql": "SELECT AVG(product_price) AS average_product_price FROM products", "explanation": "This SQL query calculates the average price of products by using the AVG function on the 'product_price' column from the 'products' table. The result is aliased as 'average_product_price' for clarity."}
{"sql": "SELECT AVG(p.product_price) AS average_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id", "explanation": "To find the average price of the products being ordered, we need to join the 'products' table with the 'order_items' table using the 'product_id' column. The SQL query calculates the average of the 'product_price' column from the 'products' table, ensuring we only consider products that are linked to orders in the 'order_items' table."}
{"sql": "SELECT AVG(p.product_price) AS average_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id", "explanation": "This SQL query calculates the average price of all products being ordered. It joins the 'products' table with the 'order_items' table on the 'product_id' column to ensure only products that are part of an order are considered. The AVG function is used to compute the average of the 'product_price' column from the 'products' table."}
{"sql": "SELECT c.email_address, c.town_city, c.county FROM customers c WHERE c.gender_code = (SELECT gender_code FROM customers GROUP BY gender_code ORDER BY COUNT(*) ASC LIMIT 1)", "explanation": "This SQL query retrieves the email address, town, and county of customers who belong to the least common gender. It uses a subquery to find the gender code with the smallest count in the customers table, then selects the relevant customer details where the gender code matches this least common gender."}
{"sql": "SELECT c.email_address, c.town_city, c.county FROM customers c WHERE c.gender_code = (SELECT gender_code FROM orders o JOIN customers c ON o.customer_id = c.customer_id GROUP BY c.gender_code ORDER BY COUNT(o.order_id) ASC LIMIT 1)", "explanation": "This SQL query retrieves the email addresses, cities, and counties of customers who belong to the gender that orders less frequently. It first identifies the gender with the fewest orders by grouping orders by gender and ordering by the count of orders in ascending order, then limits the result to the least frequent gender. Finally, it selects the required customer details from the customers table where the gender code matches the identified gender."}
{"sql": "SELECT o.date_order_placed FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN customer_payment_methods cpm ON c.customer_id = cpm.customer_id GROUP BY o.customer_id HAVING COUNT(DISTINCT cpm.payment_method_code) >= 2", "explanation": "This SQL query selects the order date from the 'orders' table. It joins the 'customers' table to link orders to customers and the 'customer_payment_methods' table to count payment methods per customer. The GROUP BY clause groups orders by customer ID, and the HAVING clause filters out customers with fewer than 2 distinct payment methods."}
{"sql": "SELECT o.date_order_placed FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN customer_payment_methods cpm ON c.customer_id = cpm.customer_id GROUP BY o.customer_id HAVING COUNT(DISTINCT cpm.payment_method_code) >= 2", "explanation": "This SQL query retrieves the order dates from the 'orders' table for customers who have at least 2 different payment methods. It joins the 'orders' table with the 'customers' and 'customer_payment_methods' tables to link orders with customer payment methods. The GROUP BY clause groups the results by customer ID, and the HAVING clause filters out customers with fewer than 2 distinct payment methods."}
{"sql": "SELECT order_status_code, COUNT(*) as count FROM orders GROUP BY order_status_code ORDER BY count ASC LIMIT 1;", "explanation": "This SQL query retrieves the most uncommon order status by grouping the 'orders' table by 'order_status_code' and counting the occurrences of each status. It then orders the results in ascending order of count and limits the output to the least common status. The 'order_status_code' column is used to identify different order statuses, and the COUNT(*) function counts how many times each status appears."}
{"sql": "SELECT order_status_code, COUNT(*) as count FROM orders GROUP BY order_status_code ORDER BY count ASC LIMIT 1;", "explanation": "This SQL query retrieves the least common order status from the 'orders' table. It groups the records by 'order_status_code', counts the occurrences of each status, and then orders the results in ascending order based on the count. The 'LIMIT 1' clause ensures that only the least common status is returned."}
{"sql": "SELECT p.product_id, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id HAVING COUNT(oi.order_item_id) > 3", "explanation": "This SQL query selects the product ID and description from the 'products' table. It joins the 'order_items' table on the product ID to count the number of times each product has been sold. The GROUP BY clause groups the results by product ID, and the HAVING clause filters out products that have been sold more than 3 times."}
{"sql": "SELECT p.product_id, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id HAVING COUNT(oi.order_item_id) > 3", "explanation": "This SQL query selects the product ID and description from the 'products' table. It joins the 'order_items' table on the product ID to count the number of times each product has been sold. The GROUP BY clause groups the results by product ID, and the HAVING clause filters out products sold 3 times or fewer, ensuring only products sold more than 3 times are included in the results."}
{"sql": "SELECT i.invoice_date, i.invoice_number FROM invoices i JOIN shipments s ON i.invoice_number = s.invoice_number GROUP BY i.invoice_number HAVING COUNT(s.shipment_id) >= 2;", "explanation": "This SQL query selects the invoice date and invoice number from the 'invoices' table. It joins the 'shipments' table on the invoice number to count the number of shipments per invoice. The GROUP BY clause groups the results by invoice number, and the HAVING clause filters the results to include only those invoices with at least 2 shipments."}
{"sql": "SELECT i.invoice_date, i.invoice_number FROM invoices i JOIN shipments s ON i.invoice_number = s.invoice_number GROUP BY i.invoice_number HAVING COUNT(s.shipment_id) >= 2", "explanation": "This SQL query selects the invoice date and invoice number from the 'invoices' table. It joins the 'shipments' table on the invoice number to find related shipments. The GROUP BY clause groups the results by invoice number, and the HAVING clause filters to include only those invoices with at least 2 related shipments."}
{"sql": "SELECT `shipment tracking number`, `shipment date` FROM `shipments`;", "explanation": "The query selects the columns 'shipment tracking number' and 'shipment date' from the 'shipments' table. These columns directly correspond to the information requested in the question. The table 'shipments' is identified from the schema where these columns are located."}
{"sql": "SELECT `shipment tracking number`, `shipment date` FROM `shipments`;", "explanation": "The query selects the columns 'shipment tracking number' and 'shipment date' from the 'shipments' table. These columns correspond to the tracking numbers and dates for all shipments listed in the database. The schema indicates that the 'shipments' table contains these relevant fields, making this a straightforward selection query."}
{"sql": "SELECT product_color, product_description, product_size FROM products WHERE product_price < (SELECT MAX(product_price) FROM products);", "explanation": "This SQL query selects the color, description, and size of products from the 'products' table where the product price is less than the maximum product price in the same table. The subquery (SELECT MAX(product_price) FROM products) calculates the maximum price, and the main query filters products below this price."}
{"sql": "SELECT product_color, product_description, product_size FROM products WHERE product_price < (SELECT MAX(product_price) FROM products);", "explanation": "This SQL query selects the columns 'product_color', 'product_description', and 'product_size' from the 'products' table. It filters the results to include only those rows where the 'product_price' is less than the maximum 'product_price' in the 'products' table. This ensures that products at the maximum price are excluded, as per the question's requirement."}
{"sql": "SELECT d.name FROM director d WHERE d.age > (SELECT AVG(age) FROM director)", "explanation": "This SQL query selects the names of directors from the 'director' table where their age is greater than the average age of all directors. The subquery (SELECT AVG(age) FROM director) calculates the average age of directors, and the main query filters out those directors whose age exceeds this average."}
{"sql": "SELECT d.name FROM director d ORDER BY d.age DESC LIMIT 1;", "explanation": "This SQL query selects the name of the director from the 'director' table, orders the results by age in descending order (oldest first), and limits the result to just the first row, effectively finding the name of the oldest director."}
{"sql": "SELECT COUNT(*) FROM channel WHERE internet LIKE '%bbc%';", "explanation": "This SQL query counts the number of rows in the 'channel' table where the 'internet' column contains the substring 'bbc'. The 'LIKE' operator is used with the pattern '%bbc%', which matches any string that includes 'bbc' anywhere within it. The 'COUNT(*)' function then returns the total number of such rows."}
{"sql": "SELECT COUNT(DISTINCT `digital terrestrial channel`) FROM `channel`;", "explanation": "This SQL query counts the number of unique values in the 'digital terrestrial channel' column from the 'channel' table. The DISTINCT keyword ensures that only unique values are counted, providing the total number of different digital terrestrial channels."}
{"sql": "SELECT title FROM program ORDER BY start_year DESC;", "explanation": "This SQL query selects the 'title' column from the 'program' table and orders the results by the 'start_year' column in descending order, ensuring that the most recent programs are listed first. The 'DESC' keyword is used to sort the years from newest to oldest."}
{"sql": "SELECT d.name, COUNT(p.program_id) AS program_count FROM director d JOIN program p ON d.director_id = p.director_id GROUP BY d.director_id ORDER BY program_count DESC LIMIT 1", "explanation": "This SQL query joins the 'director' and 'program' tables on the 'director_id' column, counts the number of programs each director is in charge of, and then selects the director with the highest count. The 'GROUP BY' clause groups the results by director, and the 'ORDER BY' clause sorts them in descending order by the count of programs. The 'LIMIT 1' clause ensures that only the top director is returned."}
{"sql": "SELECT d.name, d.age FROM director d JOIN program p ON d.director_id = p.director_id GROUP BY d.director_id ORDER BY COUNT(p.program_id) DESC LIMIT 1", "explanation": "This SQL query joins the 'director' and 'program' tables on the 'director_id' column. It groups the results by 'director_id' and orders them by the count of 'program_id' in descending order. The 'LIMIT 1' clause ensures that only the director with the most programs is selected. The query returns the name and age of this director."}
{"sql": "SELECT title FROM program ORDER BY start_year DESC LIMIT 1", "explanation": "This SQL query retrieves the title of the program with the most recent start year. It sorts the programs in descending order based on the start_year column and limits the result to the top 1 entry, ensuring that the program that began most recently is selected."}
{"sql": "SELECT c.name, c.internet FROM channel c JOIN program p ON c.channel_id = p.channel_id GROUP BY c.channel_id HAVING COUNT(p.program_id) > 1", "explanation": "This SQL query selects the name and internet link from the 'channel' table. It joins the 'channel' table with the 'program' table on the 'channel_id' column. The GROUP BY clause groups the results by 'channel_id', and the HAVING clause filters the groups to include only those with more than one program, as indicated by COUNT(p.program_id) > 1."}
{"sql": "SELECT c.name, COUNT(p.program_id) AS num_programs FROM channel c JOIN program p ON c.channel_id = p.channel_id GROUP BY c.channel_id", "explanation": "This SQL query joins the 'channel' and 'program' tables on the 'channel_id' column to count the number of programs for each channel. The 'SELECT' statement retrieves the channel name and the count of program IDs, aliased as 'num_programs'. The 'GROUP BY' clause ensures the count is aggregated per channel."}
{"sql": "SELECT COUNT(*) FROM channel WHERE channel.id NOT IN (SELECT DISTINCT channel_id FROM program)", "explanation": "This SQL query counts the number of channels that do not run any program. It first selects channels from the 'channel' table and then uses a subquery to exclude those channels that have at least one program associated with them in the 'program' table. The subquery selects distinct 'channel_id' from the 'program' table, ensuring that any channel with a program is excluded from the main query's count."}
{"sql": "SELECT d.name FROM director d JOIN program p ON d.director_id = p.director_id WHERE p.title = 'Dracula'", "explanation": "This SQL query retrieves the name of the director associated with the program titled 'Dracula'. It joins the 'director' and 'program' tables on the 'director_id' column, ensuring the correct director is linked to the program. The WHERE clause filters the results to only include the program with the title 'Dracula'."}
{"sql": "SELECT c.name, c.internet FROM channel c JOIN director_admin da ON c.channel_id = da.channel_id GROUP BY c.channel_id ORDER BY COUNT(da.director_id) DESC LIMIT 1", "explanation": "This SQL query joins the 'channel' table with the 'director_admin' table on the 'channel_id' column. It groups the results by 'channel_id' and orders them by the count of 'director_id' in descending order. The 'LIMIT 1' clause ensures that only the channel with the most directors is selected. The query returns the name and internet web of this channel."}
{"sql": "SELECT name FROM director WHERE age BETWEEN 30 AND 60;", "explanation": "This SQL query selects the 'name' column from the 'director' table where the 'age' column values are between 30 and 60. The 'director' table is identified by its index (1) in the 'table_names' list. The 'name' and 'age' columns are identified by their respective indices (8 and 9) in the 'column_names' list. The 'BETWEEN' operator is used to filter the age range."}
{"sql": "SELECT DISTINCT c.name FROM channel c JOIN director d1 ON c.channel_id = d1.channel_id WHERE d1.age < 40 INTERSECT SELECT DISTINCT c.name FROM channel c JOIN director d2 ON c.channel_id = d2.channel_id WHERE d2.age > 60", "explanation": "This SQL query retrieves the names of channels that have both a director younger than 40 and a director older than 60. It uses two subqueries joined by INTERSECT. The first subquery selects channels with directors younger than 40, and the second selects channels with directors older than 60. The INTERSECT operation ensures only channels present in both subqueries are included in the final result."}
{"sql": "SELECT c.channel_id, c.name FROM channel c LEFT JOIN director d ON c.channel_id = d.channel_id WHERE d.name IS NOT 'Hank Baskett' OR d.name IS NULL", "explanation": "This SQL query selects the 'channel_id' and 'name' from the 'channel' table. It uses a LEFT JOIN with the 'director' table to find channels associated with directors. The WHERE clause filters out channels directed by 'Hank Baskett' by checking if the director's name is not 'Hank Baskett' or if there is no director assigned (NULL). This ensures only channels not directed by Hank Baskett are included in the results."}
{"sql": "SELECT COUNT(*) FROM `radio`;", "explanation": "To find the total number of radios, we use the COUNT(*) function which counts all rows in the specified table. Here, the table of interest is 'radio'. The query will return the total count of rows in the 'radio' table, which corresponds to the total number of radios."}
{"sql": "SELECT transmitter FROM radio ORDER BY erp_kw ASC;", "explanation": "The SQL query selects the 'transmitter' column from the 'radio' table and orders the results in ascending order based on the 'erp_kw' column. This ensures that the transmitters are listed from the lowest to the highest ERP (Effective Radiated Power) in kilowatts."}
{"sql": "SELECT tv_show_name, Original_Airdate FROM tv_show;", "explanation": "The query selects the 'tv_show_name' and 'Original_Airdate' columns from the 'tv show' table. This directly answers the question by retrieving the names and original air dates of TV shows. The schema indicates that the 'tv show' table contains these relevant columns, making the query straightforward and efficient."}
{"sql": "SELECT `station name` FROM `city channel` WHERE `affiliation` != 'ABC'", "explanation": "This SQL query selects the column 'station name' from the table 'city channel'. The WHERE clause filters the rows to include only those where the 'affiliation' column is not equal to 'ABC'. This ensures that the list of station names returned are those of city channels whose affiliation is not 'ABC'."}
{"sql": "SELECT transmitter FROM radio WHERE erp_kw > 150 OR erp_kw < 30;", "explanation": "This SQL query selects the 'transmitter' column from the 'radio' table where the 'erp_kw' (Effective Radiated Power in kilowatts) is either greater than 150 or less than 30. The query uses the WHERE clause to filter the records based on the specified conditions, ensuring that only transmitters with ERP values outside the 30 to 150 range are included in the results."}
{"sql": "SELECT transmitter FROM radio ORDER BY ERP_kW DESC LIMIT 1;", "explanation": "This SQL query selects the 'transmitter' column from the 'radio' table. It orders the results in descending order based on the 'ERP_kW' column, which represents the Effective Radiated Power in kilowatts. The 'LIMIT 1' clause ensures that only the top result (the radio with the largest ERP_kW) is returned."}
{"sql": "SELECT AVG(erp_kw) AS average_erp FROM radio", "explanation": "The query calculates the average value of the 'erp_kw' column from the 'radio' table. The 'erp_kw' column represents the ERP (Effective Radiated Power) in kilowatts for each radio. The AVG function is used to compute the average of this column across all rows in the 'radio' table, and the result is labeled as 'average_erp'."}
{"sql": "SELECT affiliation, COUNT(*) AS num_city_channels FROM `city channel` GROUP BY affiliation;", "explanation": "This SQL query selects the 'affiliation' column from the 'city channel' table and counts the number of occurrences for each unique affiliation using COUNT(*). The GROUP BY clause is used to group the results by the 'affiliation' column, ensuring that the count is calculated for each distinct affiliation. This provides a list of different affiliations and the number of city channels associated with each affiliation."}
{"sql": "SELECT affiliation, COUNT(*) AS count FROM `city channel` GROUP BY affiliation ORDER BY count DESC LIMIT 1;", "explanation": "This SQL query selects the 'affiliation' column from the 'city channel' table and counts the occurrences of each affiliation. It groups the results by 'affiliation' and orders them in descending order based on the count. The 'LIMIT 1' clause ensures that only the most common affiliation is returned."}
{"sql": "SELECT affiliation FROM city_channel GROUP BY affiliation HAVING COUNT(DISTINCT city) > 3;", "explanation": "This SQL query selects the 'affiliation' column from the 'city_channel' table. It groups the results by 'affiliation' and uses the HAVING clause to filter out affiliations that are shared by more than three distinct cities. The COUNT(DISTINCT city) function counts the unique cities associated with each affiliation, ensuring that only those with more than three cities are listed."}
{"sql": "SELECT city, station_name FROM city_channel ORDER BY station_name ASC", "explanation": "This SQL query selects the 'city' and 'station_name' columns from the 'city_channel' table. The ORDER BY clause is used to sort the results in ascending alphabetical order based on the 'station_name' column. This ensures that the output lists cities and station names in the desired order."}
{"sql": "SELECT r.transmitter, c.city FROM radio r JOIN city_channel_radio cr ON r.radio_id = cr.radio_id JOIN city_channel c ON cr.city_channel_id = c.city_channel_id;", "explanation": "This SQL query joins three tables: 'radio', 'city_channel_radio', and 'city_channel'. It selects the 'transmitter' column from the 'radio' table and the 'city' column from the 'city_channel' table. The join conditions ensure that we only get transmitters for radios that are associated with specific city channels, linking 'radio_id' in 'radio' and 'city_channel_radio', and 'city_channel_id' in 'city_channel_radio' and 'city_channel'."}
{"sql": "SELECT r.transmitter, c.station_name FROM radio r JOIN city_channel c ON r.radio_id = c.radio_id ORDER BY r.erp_kw DESC", "explanation": "The query selects the transmitter from the 'radio' table and the station name from the 'city channel' table. It joins these tables on the 'radio_id' column to associate transmitters with their respective station names. The results are ordered in descending order based on the 'erp_kw' column from the 'radio' table, which represents the ERP (Effective Radiated Power) of the radios."}
{"sql": "SELECT r.transmitter, COUNT(ccr.city_channel_id) AS num_city_channels FROM radio r JOIN city_channel_radio ccr ON r.radio_id = ccr.radio_id GROUP BY r.transmitter", "explanation": "This SQL query joins the 'radio' table with the 'city_channel_radio' table on the 'radio_id' column to associate transmitters with city channels. It then groups the results by the 'transmitter' column and counts the number of city channels associated with each transmitter. The result shows each transmitter and the count of city channels it is associated with."}
