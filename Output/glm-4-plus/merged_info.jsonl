{"db_id": "soccer_3", "question": "How many clubs are there?", "query": "SELECT count(*) FROM club", "predict": "SELECT COUNT(*) FROM club", "llm_explanation": "To find the number of clubs, we use the COUNT(*) function which counts all rows in the 'club' table. The 'club' table is identified from the provided schema where 'table_names' includes 'club'. This query will return a single number representing the total number of clubs in the database.", "gold_exec_result": "[(9,)]", "predict_exec_result": "[(9,)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Count the number of clubs.", "query": "SELECT count(*) FROM club", "predict": "SELECT COUNT(*) FROM club", "llm_explanation": "The SQL query counts the number of rows in the 'club' table. The COUNT(*) function is used to count all rows, providing the total number of clubs in the database.", "gold_exec_result": "[(9,)]", "predict_exec_result": "[(9,)]", "exec_match": true}
{"db_id": "soccer_3", "question": "List the name of clubs in ascending alphabetical order.", "query": "SELECT Name FROM club ORDER BY Name ASC", "predict": "SELECT name FROM club ORDER BY name ASC;", "llm_explanation": "This SQL query selects the 'name' column from the 'club' table and orders the results in ascending alphabetical order using the ORDER BY clause. The 'club' table is identified from the provided schema where 'name' is a column in the 'club' table.", "gold_exec_result": "[('Arsenal',), ('Aston Villa',), ('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Fulham',), ('Hull City',), ('Liverpool',)]", "predict_exec_result": "[('Arsenal',), ('Aston Villa',), ('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Fulham',), ('Hull City',), ('Liverpool',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of clubs, ordered alphabetically?", "query": "SELECT Name FROM club ORDER BY Name ASC", "predict": "SELECT name FROM club ORDER BY name ASC;", "llm_explanation": "This SQL query selects the 'name' column from the 'club' table and orders the results alphabetically in ascending order using the ORDER BY clause. The 'club' table is identified from the provided schema where 'name' is a column associated with the 'club' table.", "gold_exec_result": "[('Arsenal',), ('Aston Villa',), ('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Fulham',), ('Hull City',), ('Liverpool',)]", "predict_exec_result": "[('Arsenal',), ('Aston Villa',), ('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Fulham',), ('Hull City',), ('Liverpool',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the managers and captains of clubs?", "query": "SELECT Manager ,  Captain FROM club", "predict": "SELECT club.name AS ClubName, club.manager AS Manager, club.captain AS Captain FROM club;", "llm_explanation": "This SQL query selects the name, manager, and captain from the 'club' table. The 'club' table contains columns for 'name', 'manager', and 'captain', which directly correspond to the required information. The query uses aliases (AS) to make the output columns more readable.", "gold_exec_result": "[('Ars\u00e8ne Wenger', 'Cesc F\u00e0bregas'), (\"Martin O'Neill\", 'Martin Laursen'), ('Sam Allardyce', 'Ryan Nelsen'), ('Gary Megson', 'Kevin Davies'), ('Guus Hiddink', 'John Terry'), ('David Moyes', 'Phil Neville'), ('Roy Hodgson', 'Danny Murphy'), ('Phil Brown', 'Ian Ashbee'), ('Rafael Ben\u00edtez', 'Steven Gerrard')]", "predict_exec_result": "[('Arsenal', 'Ars\u00e8ne Wenger', 'Cesc F\u00e0bregas'), ('Aston Villa', \"Martin O'Neill\", 'Martin Laursen'), ('Blackburn Rovers', 'Sam Allardyce', 'Ryan Nelsen'), ('Bolton Wanderers', 'Gary Megson', 'Kevin Davies'), ('Chelsea', 'Guus Hiddink', 'John Terry'), ('Everton', 'David Moyes', 'Phil Neville'), ('Fulham', 'Roy Hodgson', 'Danny Murphy'), ('Hull City', 'Phil Brown', 'Ian Ashbee'), ('Liverpool', 'Rafael Ben\u00edtez', 'Steven Gerrard')]", "exec_match": false}
{"db_id": "soccer_3", "question": "Return the managers and captains of all clubs.", "query": "SELECT Manager ,  Captain FROM club", "predict": "SELECT club.name AS ClubName, club.manager AS Manager, club.captain AS Captain FROM club;", "llm_explanation": "This SQL query selects the name, manager, and captain from the 'club' table. The 'club' table contains columns for 'name', 'manager', and 'captain', which are directly related to the question's requirement to return the managers and captains of all clubs. The query uses aliases ('ClubName', 'Manager', 'Captain') for better readability of the results.", "gold_exec_result": "[('Ars\u00e8ne Wenger', 'Cesc F\u00e0bregas'), (\"Martin O'Neill\", 'Martin Laursen'), ('Sam Allardyce', 'Ryan Nelsen'), ('Gary Megson', 'Kevin Davies'), ('Guus Hiddink', 'John Terry'), ('David Moyes', 'Phil Neville'), ('Roy Hodgson', 'Danny Murphy'), ('Phil Brown', 'Ian Ashbee'), ('Rafael Ben\u00edtez', 'Steven Gerrard')]", "predict_exec_result": "[('Arsenal', 'Ars\u00e8ne Wenger', 'Cesc F\u00e0bregas'), ('Aston Villa', \"Martin O'Neill\", 'Martin Laursen'), ('Blackburn Rovers', 'Sam Allardyce', 'Ryan Nelsen'), ('Bolton Wanderers', 'Gary Megson', 'Kevin Davies'), ('Chelsea', 'Guus Hiddink', 'John Terry'), ('Everton', 'David Moyes', 'Phil Neville'), ('Fulham', 'Roy Hodgson', 'Danny Murphy'), ('Hull City', 'Phil Brown', 'Ian Ashbee'), ('Liverpool', 'Rafael Ben\u00edtez', 'Steven Gerrard')]", "exec_match": false}
{"db_id": "soccer_3", "question": "List the name of clubs whose manufacturer is not \"Nike\"", "query": "SELECT Name FROM club WHERE Manufacturer != \"Nike\"", "predict": "SELECT name FROM club WHERE manufacturer != 'Nike';", "llm_explanation": "The query selects the 'name' column from the 'club' table where the 'manufacturer' column is not equal to 'Nike'. This directly addresses the requirement to list clubs whose manufacturer is not 'Nike'.", "gold_exec_result": "[('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Hull City',), ('Liverpool',)]", "predict_exec_result": "[('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Hull City',), ('Liverpool',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of clubs who do not have the manufacturer Nike?", "query": "SELECT Name FROM club WHERE Manufacturer != \"Nike\"", "predict": "SELECT name FROM club WHERE manufacturer != 'Nike';", "llm_explanation": "This SQL query selects the 'name' column from the 'club' table where the 'manufacturer' column is not equal to 'Nike'. It filters out clubs that have Nike as their manufacturer, thus listing only those clubs that do not use Nike.", "gold_exec_result": "[('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Hull City',), ('Liverpool',)]", "predict_exec_result": "[('Blackburn Rovers',), ('Bolton Wanderers',), ('Chelsea',), ('Everton',), ('Hull City',), ('Liverpool',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of players in ascending order of wins count?", "query": "SELECT Name FROM player ORDER BY Wins_count ASC", "predict": "SELECT p.name FROM player p ORDER BY p.wins_count ASC", "llm_explanation": "This SQL query selects the 'name' column from the 'player' table and orders the results in ascending order based on the 'wins_count' column. The 'player' table is identified by its index (1) in the 'table_names' list. The 'name' and 'wins_count' columns are identified by their respective indices (9 and 12) in the 'column_names' list.", "gold_exec_result": "[('Greg Norman',), ('Jim Gallagher, Jr.',), ('David Frost',), ('Paul Azinger',), ('Nick Price',)]", "predict_exec_result": "[('Greg Norman',), ('Jim Gallagher, Jr.',), ('David Frost',), ('Paul Azinger',), ('Nick Price',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Return the names of players in order of count of wins, ascending.", "query": "SELECT Name FROM player ORDER BY Wins_count ASC", "predict": "SELECT p.name FROM player p ORDER BY p.wins_count ASC", "llm_explanation": "This SQL query selects the 'name' column from the 'player' table and orders the results by the 'wins_count' column in ascending order. The 'player' table is identified by its index (1) in the 'table_names' list. The 'name' and 'wins_count' columns are identified by their respective indices in the 'column_names' list.", "gold_exec_result": "[('Greg Norman',), ('Jim Gallagher, Jr.',), ('David Frost',), ('Paul Azinger',), ('Nick Price',)]", "predict_exec_result": "[('Greg Norman',), ('Jim Gallagher, Jr.',), ('David Frost',), ('Paul Azinger',), ('Nick Price',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What is the name of the player with the highest earnings?", "query": "SELECT Name FROM player ORDER BY Earnings DESC LIMIT 1", "predict": "SELECT p.name FROM player p ORDER BY p.earnings DESC LIMIT 1", "llm_explanation": "This SQL query selects the name of the player from the 'player' table, orders the results by the 'earnings' column in descending order to get the highest earnings first, and limits the result to just the top 1 entry. This ensures that the name of the player with the highest earnings is returned.", "gold_exec_result": "[('Nick Price',)]", "predict_exec_result": "[('Nick Price',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Return the name of the player who earns the most money.", "query": "SELECT Name FROM player ORDER BY Earnings DESC LIMIT 1", "predict": "SELECT p.name FROM player p ORDER BY p.earnings DESC LIMIT 1", "llm_explanation": "This SQL query selects the name of the player from the 'player' table, orders the results by the 'earnings' column in descending order to get the player with the highest earnings, and limits the result to just the top player using LIMIT 1.", "gold_exec_result": "[('Nick Price',)]", "predict_exec_result": "[('Nick Price',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the distinct countries of players with earnings higher than 1200000?", "query": "SELECT DISTINCT Country FROM player WHERE Earnings  >  1200000", "predict": "SELECT DISTINCT country FROM player WHERE earnings > 1200000", "llm_explanation": "This SQL query selects distinct countries from the 'player' table where the 'earnings' column value is greater than 1200000. The 'DISTINCT' keyword ensures that each country appears only once in the result set, even if multiple players from the same country meet the earnings criteria.", "gold_exec_result": "[('Zimbabwe',), ('United States',), ('Australia',)]", "predict_exec_result": "[('Zimbabwe',), ('United States',), ('Australia',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "From which countries are players who make more than 1200000 from?", "query": "SELECT DISTINCT Country FROM player WHERE Earnings  >  1200000", "predict": "SELECT DISTINCT p.country FROM player p WHERE p.earnings > 1200000", "llm_explanation": "This SQL query selects distinct countries from the 'player' table where the 'earnings' column value is greater than 1200000. The 'DISTINCT' keyword ensures that each country is listed only once, even if multiple players from the same country meet the earnings criteria.", "gold_exec_result": "[('Zimbabwe',), ('United States',), ('Australia',)]", "predict_exec_result": "[('Zimbabwe',), ('United States',), ('Australia',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What is the country of the player with the highest earnings among players that have more than 2 win counts?", "query": "SELECT Country FROM player WHERE Wins_count  >  2 ORDER BY Earnings DESC LIMIT 1", "predict": "SELECT p.country FROM player p WHERE p.wins_count > 2 ORDER BY p.earnings DESC LIMIT 1", "llm_explanation": "This SQL query selects the country of the player with the highest earnings among those who have more than 2 win counts. It filters players with `wins_count > 2`, orders them by `earnings` in descending order to get the highest earner at the top, and uses `LIMIT 1` to retrieve only the top player's country.", "gold_exec_result": "[('Zimbabwe',)]", "predict_exec_result": "[('Zimbabwe',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Of players who have more than 2 wins, what is the country of the player who makes the most?", "query": "SELECT Country FROM player WHERE Wins_count  >  2 ORDER BY Earnings DESC LIMIT 1", "predict": "SELECT p.country FROM player p WHERE p.wins_count > 2 GROUP BY p.country ORDER BY COUNT(p.player_id) DESC LIMIT 1;", "llm_explanation": "This SQL query selects the country of players who have more than 2 wins. It groups the results by country and orders them by the count of player IDs in descending order, ensuring that the country with the most players who have more than 2 wins is at the top. The LIMIT 1 clause ensures that only the top country is returned.", "gold_exec_result": "[('Zimbabwe',)]", "predict_exec_result": "[('Zimbabwe',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Show names of players and names of clubs they are in.", "query": "SELECT T2.Name ,  T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "predict": "SELECT player.name AS player_name, club.name AS club_name FROM player JOIN club ON player.club_id = club.club_id", "llm_explanation": "This SQL query joins the 'player' and 'club' tables on the 'club_id' column to retrieve the names of players and their respective clubs. The SELECT statement specifies the columns to display: 'player.name' as 'player_name' and 'club.name' as 'club_name'. The JOIN operation ensures that only matching records from both tables are included in the result set.", "gold_exec_result": "[('Nick Price', 'Arsenal'), ('Paul Azinger', 'Blackburn Rovers'), ('Greg Norman', 'Chelsea'), ('Jim Gallagher, Jr.', 'Everton'), ('David Frost', 'Fulham')]", "predict_exec_result": "[('Nick Price', 'Arsenal'), ('Paul Azinger', 'Blackburn Rovers'), ('Greg Norman', 'Chelsea'), ('Jim Gallagher, Jr.', 'Everton'), ('David Frost', 'Fulham')]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of players and the corresponding clubs that they are in?", "query": "SELECT T2.Name ,  T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID", "predict": "SELECT player.name AS player_name, club.name AS club_name FROM player JOIN club ON player.club_id = club.club_id", "llm_explanation": "This SQL query retrieves the names of players and their corresponding clubs. It uses an INNER JOIN to combine rows from the 'player' and 'club' tables where the 'club_id' in the 'player' table matches the 'club_id' in the 'club' table. The SELECT statement specifies the columns to return, renaming them to 'player_name' and 'club_name' for clarity.", "gold_exec_result": "[('Nick Price', 'Arsenal'), ('Paul Azinger', 'Blackburn Rovers'), ('Greg Norman', 'Chelsea'), ('Jim Gallagher, Jr.', 'Everton'), ('David Frost', 'Fulham')]", "predict_exec_result": "[('Nick Price', 'Arsenal'), ('Paul Azinger', 'Blackburn Rovers'), ('Greg Norman', 'Chelsea'), ('Jim Gallagher, Jr.', 'Everton'), ('David Frost', 'Fulham')]", "exec_match": true}
{"db_id": "soccer_3", "question": "Show names of clubs that have players with more than 2 win counts.", "query": "SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Wins_count  >  2", "predict": "SELECT DISTINCT c.name FROM club c JOIN player p ON c.club_id = p.club_id WHERE p.wins_count > 2", "llm_explanation": "This SQL query selects distinct club names from the 'club' table where there are players in the 'player' table with more than 2 win counts. The JOIN operation links the 'club' and 'player' tables via the 'club_id' column. The WHERE clause filters players with 'wins_count' greater than 2, ensuring only clubs with such players are listed.", "gold_exec_result": "[('Arsenal',), ('Blackburn Rovers',)]", "predict_exec_result": "[('Arsenal',), ('Blackburn Rovers',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of clubs that have players who have won more than twice?", "query": "SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T2.Wins_count  >  2", "predict": "SELECT DISTINCT c.name FROM club c JOIN player p ON c.club_id = p.club_id WHERE p.wins_count > 2;", "llm_explanation": "This SQL query selects distinct club names from the 'club' table where there are players in the 'player' table who have a 'wins_count' greater than 2. The JOIN operation links the 'club' and 'player' tables via the 'club_id' column. The DISTINCT keyword ensures that each club name appears only once in the result set.", "gold_exec_result": "[('Arsenal',), ('Blackburn Rovers',)]", "predict_exec_result": "[('Arsenal',), ('Blackburn Rovers',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Show names of players from the club with manager \"Sam Allardyce\".", "query": "SELECT T2.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.Manager  =  \"Sam Allardyce\"", "predict": "SELECT p.name FROM player p JOIN club c ON p.club_id = c.club_id WHERE c.manager = 'Sam Allardyce';", "llm_explanation": "This SQL query retrieves the names of players from the 'player' table who belong to a club managed by 'Sam Allardyce'. It uses an INNER JOIN to connect the 'player' table with the 'club' table via the 'club_id' column. The WHERE clause filters the results to include only clubs where the manager is 'Sam Allardyce'.", "gold_exec_result": "[('Paul Azinger',)]", "predict_exec_result": "[('Paul Azinger',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of players from the club managed by Sam Allardyce?", "query": "SELECT T2.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID WHERE T1.Manager  =  \"Sam Allardyce\"", "predict": "SELECT p.name FROM player p JOIN club c ON p.club_id = c.club_id WHERE c.manager = 'Sam Allardyce';", "llm_explanation": "This SQL query joins the 'player' and 'club' tables on the 'club_id' column to find players whose club is managed by 'Sam Allardyce'. It selects the names of these players.", "gold_exec_result": "[('Paul Azinger',)]", "predict_exec_result": "[('Paul Azinger',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Show names of clubs in descending order of average earnings of players belonging.", "query": "SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID GROUP BY T1.Club_ID ORDER BY avg(T2.Earnings) DESC", "predict": "SELECT c.name FROM club c JOIN player p ON c.club_id = p.club_id GROUP BY c.name ORDER BY AVG(p.earnings) DESC", "llm_explanation": "This SQL query joins the 'club' and 'player' tables on the 'club_id' column. It then groups the results by the club's name and orders them in descending order based on the average earnings of the players belonging to each club. The SELECT statement retrieves the names of the clubs.", "gold_exec_result": "[('Arsenal',), ('Blackburn Rovers',), ('Chelsea',), ('Everton',), ('Fulham',)]", "predict_exec_result": "[('Arsenal',), ('Blackburn Rovers',), ('Chelsea',), ('Everton',), ('Fulham',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of clubs, ordered descending by the average earnings of players within each?", "query": "SELECT T1.Name FROM club AS T1 JOIN player AS T2 ON T1.Club_ID  =  T2.Club_ID GROUP BY T1.Club_ID ORDER BY avg(T2.Earnings) DESC", "predict": "SELECT c.name AS club_name, AVG(p.earnings) AS avg_earnings FROM club c JOIN player p ON c.club_id = p.club_id GROUP BY c.name ORDER BY avg_earnings DESC", "llm_explanation": "This SQL query joins the 'club' and 'player' tables on the 'club_id' column. It then groups the results by the club's name and calculates the average earnings of players in each club. Finally, it orders the results in descending order based on the average earnings, providing the names of clubs with the highest average player earnings at the top.", "gold_exec_result": "[('Arsenal',), ('Blackburn Rovers',), ('Chelsea',), ('Everton',), ('Fulham',)]", "predict_exec_result": "[('Arsenal', 1478557.0), ('Blackburn Rovers', 1458456.0), ('Chelsea', 1359653.0), ('Everton', 1078870.0), ('Fulham', 1030717.0)]", "exec_match": false}
{"db_id": "soccer_3", "question": "Show different manufacturers and the number of clubs they are associated with.", "query": "SELECT Manufacturer ,  COUNT(*) FROM club GROUP BY Manufacturer", "predict": "SELECT manufacturer, COUNT(DISTINCT club_id) AS club_count FROM club GROUP BY manufacturer;", "llm_explanation": "This SQL query selects the 'manufacturer' column from the 'club' table and counts the distinct 'club_id' associated with each manufacturer. The COUNT(DISTINCT club_id) ensures that each club is counted only once per manufacturer. The GROUP BY clause groups the results by manufacturer, allowing the count to be calculated for each unique manufacturer.", "gold_exec_result": "[('Nike', 3), ('Reebok', 1), ('Umbro', 3), ('adidas', 2)]", "predict_exec_result": "[('Nike', 3), ('Reebok', 1), ('Umbro', 3), ('adidas', 2)]", "exec_match": true}
{"db_id": "soccer_3", "question": "How many clubs use each manufacturer?", "query": "SELECT Manufacturer ,  COUNT(*) FROM club GROUP BY Manufacturer", "predict": "SELECT manufacturer, COUNT(*) AS club_count FROM club GROUP BY manufacturer", "llm_explanation": "This SQL query counts the number of clubs that use each manufacturer. It selects the 'manufacturer' column from the 'club' table and uses the COUNT(*) function to count the number of occurrences for each manufacturer. The GROUP BY clause groups the results by the 'manufacturer' column, ensuring that the count is calculated for each unique manufacturer.", "gold_exec_result": "[('Nike', 3), ('Reebok', 1), ('Umbro', 3), ('adidas', 2)]", "predict_exec_result": "[('Nike', 3), ('Reebok', 1), ('Umbro', 3), ('adidas', 2)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Please show the most common manufacturer of clubs.", "query": "SELECT Manufacturer FROM club GROUP BY Manufacturer ORDER BY COUNT(*) DESC LIMIT 1", "predict": "SELECT `manufacturer`, COUNT(*) AS `count` FROM `club` GROUP BY `manufacturer` ORDER BY `count` DESC LIMIT 1;", "llm_explanation": "This SQL query selects the `manufacturer` column from the `club` table, counts the occurrences of each manufacturer, and groups the results by manufacturer. It then orders the results in descending order based on the count and limits the output to the most common manufacturer. This helps identify the manufacturer with the highest number of clubs.", "gold_exec_result": "[('Umbro',)]", "predict_exec_result": "[('Umbro', 3)]", "exec_match": false}
{"db_id": "soccer_3", "question": "Which manufacturer is most common among clubs?", "query": "SELECT Manufacturer FROM club GROUP BY Manufacturer ORDER BY COUNT(*) DESC LIMIT 1", "predict": "SELECT manufacturer, COUNT(*) AS count FROM club GROUP BY manufacturer ORDER BY count DESC LIMIT 1;", "llm_explanation": "This SQL query selects the 'manufacturer' column from the 'club' table and counts the occurrences of each manufacturer. It groups the results by 'manufacturer' and orders them in descending order based on the count. The 'LIMIT 1' clause ensures that only the most common manufacturer is returned.", "gold_exec_result": "[('Umbro',)]", "predict_exec_result": "[('Umbro', 3)]", "exec_match": false}
{"db_id": "soccer_3", "question": "List the manufacturers that are associated with more than one club.", "query": "SELECT Manufacturer FROM club GROUP BY Manufacturer HAVING COUNT(*)  >  1", "predict": "SELECT manufacturer FROM club GROUP BY manufacturer HAVING COUNT(*) > 1", "llm_explanation": "This SQL query selects the 'manufacturer' column from the 'club' table, groups the results by 'manufacturer', and filters to include only those manufacturers that are associated with more than one club, as indicated by the COUNT(*) > 1 condition.", "gold_exec_result": "[('Nike',), ('Umbro',), ('adidas',)]", "predict_exec_result": "[('Nike',), ('Umbro',), ('adidas',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Which manufacturers work for more than 1 club?", "query": "SELECT Manufacturer FROM club GROUP BY Manufacturer HAVING COUNT(*)  >  1", "predict": "SELECT Manufacturer, COUNT(DISTINCT Club_ID) AS ClubCount FROM club GROUP BY Manufacturer HAVING ClubCount > 1", "llm_explanation": "This SQL query selects the 'Manufacturer' and counts the distinct 'Club_ID' for each manufacturer from the 'club' table. It groups the results by 'Manufacturer' and filters to include only those manufacturers associated with more than one club, indicating they work for more than one club.", "gold_exec_result": "[('Nike',), ('Umbro',), ('adidas',)]", "predict_exec_result": "[('Nike', 3), ('Umbro', 3), ('adidas', 2)]", "exec_match": false}
{"db_id": "soccer_3", "question": "List the country that have more than one player.", "query": "SELECT Country FROM player GROUP BY Country HAVING COUNT(*)  >  1", "predict": "SELECT country FROM player GROUP BY country HAVING COUNT(player_id) > 1", "llm_explanation": "This SQL query selects the 'country' column from the 'player' table, groups the results by 'country', and uses the HAVING clause to filter out countries that have more than one player, as indicated by COUNT(player_id) > 1.", "gold_exec_result": "[('United States',)]", "predict_exec_result": "[('United States',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Which countries have produced more than one player?", "query": "SELECT Country FROM player GROUP BY Country HAVING COUNT(*)  >  1", "predict": "SELECT country FROM player GROUP BY country HAVING COUNT(player_id) > 1", "llm_explanation": "This SQL query selects the 'country' column from the 'player' table, groups the results by 'country', and uses the HAVING clause to filter out countries that have produced more than one player, as indicated by a count of 'player_id' greater than 1.", "gold_exec_result": "[('United States',)]", "predict_exec_result": "[('United States',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "List the name of clubs that do not have players.", "query": "SELECT Name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player)", "predict": "SELECT c.name FROM club c LEFT JOIN player p ON c.club_id = p.club_id WHERE p.player_id IS NULL", "llm_explanation": "This SQL query selects the names of clubs that do not have any players. It uses a LEFT JOIN to combine the 'club' and 'player' tables based on the 'club_id' column. The WHERE clause filters out rows where 'player_id' is NULL, indicating that there are no players associated with those clubs.", "gold_exec_result": "[('Aston Villa',), ('Bolton Wanderers',), ('Hull City',), ('Liverpool',)]", "predict_exec_result": "[('Aston Villa',), ('Bolton Wanderers',), ('Hull City',), ('Liverpool',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What are the names of clubs that do not have any players?", "query": "SELECT Name FROM club WHERE Club_ID NOT IN (SELECT Club_ID FROM player)", "predict": "SELECT c.name FROM club c LEFT JOIN player p ON c.club_id = p.club_id WHERE p.player_id IS NULL", "llm_explanation": "This SQL query selects the names of clubs from the 'club' table and performs a left join with the 'player' table on the 'club_id' column. The WHERE clause filters out rows where there is no corresponding 'player_id' in the 'player' table, indicating that the club has no players.", "gold_exec_result": "[('Aston Villa',), ('Bolton Wanderers',), ('Hull City',), ('Liverpool',)]", "predict_exec_result": "[('Aston Villa',), ('Bolton Wanderers',), ('Hull City',), ('Liverpool',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Show the country of players with earnings more than 1400000 and players with earnings less than 1100000.", "query": "SELECT Country FROM player WHERE Earnings  >  1400000 INTERSECT SELECT Country FROM player WHERE Earnings  <  1100000", "predict": "SELECT DISTINCT country FROM player WHERE earnings > 1400000 OR earnings < 1100000;", "llm_explanation": "This SQL query selects unique countries from the 'player' table where players have earnings either greater than 1,400,000 or less than 1,100,000. The DISTINCT keyword ensures each country is listed only once, avoiding duplicates.", "gold_exec_result": "[('United States',)]", "predict_exec_result": "[('Zimbabwe',), ('United States',), ('South Africa',)]", "exec_match": false}
{"db_id": "soccer_3", "question": "Which country has produced both players with earnings over 1400000 and players with earnings below 1100000?", "query": "SELECT Country FROM player WHERE Earnings  >  1400000 INTERSECT SELECT Country FROM player WHERE Earnings  <  1100000", "predict": "SELECT DISTINCT p1.country FROM player p1 JOIN player p2 ON p1.country = p2.country WHERE p1.earnings > 1400000 AND p2.earnings < 1100000", "llm_explanation": "This SQL query selects distinct countries from the 'player' table where there are players with earnings over 1400000 and players with earnings below 1100000. It uses a self-join on the 'player' table to compare earnings of players from the same country, ensuring that both conditions are met for the same country.", "gold_exec_result": "[('United States',)]", "predict_exec_result": "[('United States',)]", "exec_match": true}
{"db_id": "soccer_3", "question": "What is the number of distinct countries of all players?", "query": "SELECT COUNT (DISTINCT Country) FROM player", "predict": "SELECT COUNT(DISTINCT country) FROM player", "llm_explanation": "The query selects the count of distinct values in the 'country' column from the 'player' table. This will give the number of unique countries represented by all players in the database.", "gold_exec_result": "[(4,)]", "predict_exec_result": "[(4,)]", "exec_match": true}
{"db_id": "soccer_3", "question": "How many different countries are players from?", "query": "SELECT COUNT (DISTINCT Country) FROM player", "predict": "SELECT COUNT(DISTINCT country) FROM player", "llm_explanation": "The query counts the number of unique countries from which players originate. It uses the `COUNT(DISTINCT country)` function to ensure each country is counted only once, targeting the 'country' column in the 'player' table.", "gold_exec_result": "[(4,)]", "predict_exec_result": "[(4,)]", "exec_match": true}
{"db_id": "soccer_3", "question": "Show the earnings of players from country \"Australia\" or \"Zimbabwe\".", "query": "SELECT Earnings FROM player WHERE Country  =  \"Australia\" OR Country  =  \"Zimbabwe\"", "predict": "SELECT p.name, p.earnings FROM player p WHERE p.country IN ('Australia', 'Zimbabwe')", "llm_explanation": "This SQL query selects the name and earnings of players from the 'player' table where the country is either 'Australia' or 'Zimbabwe'. The 'IN' clause is used to specify multiple values in the WHERE condition, making the query concise and efficient for filtering based on multiple countries.", "gold_exec_result": "[(1478557.0,), (1359653.0,)]", "predict_exec_result": "[('Nick Price', 1478557.0), ('Greg Norman', 1359653.0)]", "exec_match": false}
{"db_id": "soccer_3", "question": "What are the earnings of players from either of the countries of Australia or Zimbabwe?", "query": "SELECT Earnings FROM player WHERE Country  =  \"Australia\" OR Country  =  \"Zimbabwe\"", "predict": "SELECT SUM(earnings) AS total_earnings FROM player WHERE country IN ('Australia', 'Zimbabwe')", "llm_explanation": "This SQL query calculates the total earnings of players from either Australia or Zimbabwe. It uses the `SUM` aggregate function on the `earnings` column from the `player` table, filtering the results with the `WHERE` clause to include only players whose `country` is either 'Australia' or 'Zimbabwe'. The result is aliased as `total_earnings` for clarity.", "gold_exec_result": "[(1478557.0,), (1359653.0,)]", "predict_exec_result": "[(2838210.0,)]", "exec_match": false}
{"db_id": "e_commerce", "question": "List the id, first name and last name of the customers who both have placed more than 2 orders and have bought at least 3 items.", "query": "SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >  2 INTERSECT SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.customer_id HAVING count(*)  >= 3", "predict": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id HAVING COUNT(DISTINCT o.order_id) > 2 AND COUNT(oi.order_item_id) >= 3", "llm_explanation": "This SQL query selects the customer ID, first name, and last name from the 'customers' table. It joins the 'orders' table to count the number of distinct orders per customer and the 'order_items' table to count the number of items bought. The GROUP BY clause groups the results by customer ID, and the HAVING clause filters out customers who have placed more than 2 orders and bought at least 3 items.", "gold_exec_result": "[(13, 'Jamel', 'Koelpin')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the ids, first and last names of the customers who have ordered more than twice and have bought at least 3 items?", "query": "SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >  2 INTERSECT SELECT T1.customer_id ,  T1.customer_first_name ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.customer_id HAVING count(*)  >= 3", "predict": "SELECT c.customer_id, c.customer_first_name, c.customer_last_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id HAVING COUNT(DISTINCT o.order_id) > 2 AND COUNT(oi.order_item_id) >= 3", "llm_explanation": "This SQL query selects the customer ID, first name, and last name from the 'customers' table. It joins the 'orders' table to count the number of distinct orders per customer and the 'order_items' table to count the number of items ordered. The GROUP BY clause groups the results by customer ID, and the HAVING clause filters out customers who have ordered more than twice and have bought at least 3 items.", "gold_exec_result": "[(13, 'Jamel', 'Koelpin')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "For the orders with any produts, how many products does each orders contain ? List the order id, status and the number.", "query": "SELECT T1.order_id ,  T1.order_status_code ,  count(*) FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id", "predict": "SELECT o.order_id, o.order_status_code, COUNT(oi.product_id) AS product_count FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id, o.order_status_code;", "llm_explanation": "This SQL query joins the 'orders' and 'order_items' tables on the 'order_id' column to count the number of products associated with each order. It selects the 'order_id' and 'order_status_code' from the 'orders' table and counts the 'product_id' from the 'order_items' table, grouping the results by 'order_id' and 'order_status_code' to ensure each order is listed once with its respective product count.", "gold_exec_result": "[(1, 'Cancelled', 1), (3, 'Cancelled', 2), (4, 'Delivered', 1), (6, 'Delivered', 1), (7, 'Part Completed', 1), (8, 'Part Completed', 1), (10, 'Part Completed', 2), (17, 'Delivered', 1), (18, 'Cancelled', 2), (19, 'Part Completed', 2), (20, 'Cancelled', 1)]", "predict_exec_result": "[(1, 'Cancelled', 1), (3, 'Cancelled', 2), (4, 'Delivered', 1), (6, 'Delivered', 1), (7, 'Part Completed', 1), (8, 'Part Completed', 1), (10, 'Part Completed', 2), (17, 'Delivered', 1), (18, 'Cancelled', 2), (19, 'Part Completed', 2), (20, 'Cancelled', 1)]", "exec_match": true}
{"db_id": "e_commerce", "question": "For every order, how many products does it contain, and what are the orders' statuses and ids?", "query": "SELECT T1.order_id ,  T1.order_status_code ,  count(*) FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id", "predict": "SELECT o.order_id, COUNT(oi.product_id) AS product_count, o.order_status_code FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id, o.order_status_code;", "llm_explanation": "This SQL query joins the 'orders' and 'order_items' tables on the 'order_id' column to count the number of products in each order. It selects the 'order_id', the count of 'product_id' as 'product_count', and the 'order_status_code' from the 'orders' table. The GROUP BY clause groups the results by 'order_id' and 'order_status_code' to ensure accurate counts for each order.", "gold_exec_result": "[(1, 'Cancelled', 1), (3, 'Cancelled', 2), (4, 'Delivered', 1), (6, 'Delivered', 1), (7, 'Part Completed', 1), (8, 'Part Completed', 1), (10, 'Part Completed', 2), (17, 'Delivered', 1), (18, 'Cancelled', 2), (19, 'Part Completed', 2), (20, 'Cancelled', 1)]", "predict_exec_result": "[(1, 1, 'Cancelled'), (3, 2, 'Cancelled'), (4, 1, 'Delivered'), (6, 1, 'Delivered'), (7, 1, 'Part Completed'), (8, 1, 'Part Completed'), (10, 2, 'Part Completed'), (17, 1, 'Delivered'), (18, 2, 'Cancelled'), (19, 2, 'Part Completed'), (20, 1, 'Cancelled')]", "exec_match": false}
{"db_id": "e_commerce", "question": "List the dates of the orders which were placed at the earliest time or have more than 1 items.", "query": "SELECT min(date_order_placed) FROM Orders UNION SELECT T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  1", "predict": "SELECT DISTINCT o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id WHERE o.date_order_placed = (SELECT MIN(date_order_placed) FROM orders) OR (SELECT COUNT(*) FROM order_items WHERE order_id = o.order_id) > 1;", "llm_explanation": "This SQL query selects distinct dates of orders that either were placed at the earliest time or have more than 1 item. It uses a subquery to find the earliest order date and another subquery to count items per order, joining the 'orders' and 'order_items' tables to filter the required orders.", "gold_exec_result": "[('2017-05-02 00:04:13',), ('2017-05-15 15:13:44',), ('2017-09-10 08:27:04',), ('2017-09-25 14:30:23',), ('2017-12-10 23:45:42',)]", "predict_exec_result": "[('2017-09-25 14:30:23',), ('2017-09-10 08:27:04',), ('2017-05-15 15:13:44',), ('2017-12-10 23:45:42',)]", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the dates of the earliest order and the dates of all orders with more than 1 item?", "query": "SELECT min(date_order_placed) FROM Orders UNION SELECT T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >  1", "predict": "SELECT MIN(o.date_order_placed) AS earliest_order_date, o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id HAVING COUNT(oi.order_item_id) > 1;", "llm_explanation": "This SQL query retrieves the date of the earliest order and the dates of all orders with more than one item. It joins the 'orders' and 'order_items' tables on the 'order_id' column, groups the results by 'order_id', and uses the HAVING clause to filter groups with more than one item. The MIN function is used to find the earliest order date.", "gold_exec_result": "[('2017-05-02 00:04:13',), ('2017-05-15 15:13:44',), ('2017-09-10 08:27:04',), ('2017-09-25 14:30:23',), ('2017-12-10 23:45:42',)]", "predict_exec_result": "[('2017-09-10 08:27:04', '2017-09-10 08:27:04'), ('2017-09-25 14:30:23', '2017-09-25 14:30:23'), ('2017-05-15 15:13:44', '2017-05-15 15:13:44'), ('2017-12-10 23:45:42', '2017-12-10 23:45:42')]", "exec_match": false}
{"db_id": "e_commerce", "question": "Which customers did not make any orders? List the first name, middle initial and last name.", "query": "SELECT customer_first_name ,  customer_middle_initial ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id", "predict": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_id IS NULL;", "llm_explanation": "This SQL query selects the first name, middle initial, and last name from the 'customers' table. It uses a LEFT JOIN with the 'orders' table on the 'customer_id' column to find all customers. The WHERE clause filters out customers who have made orders by checking for NULL 'order_id' in the 'orders' table, thus listing only those customers who did not make any orders.", "gold_exec_result": "[('Angeline', 'H', 'Huel'), ('David', 'T', 'West'), ('Jailyn', 'C', 'Murray'), ('Marlen', 'W', 'Anderson')]", "predict_exec_result": "[('Jailyn', 'C', 'Murray'), ('David', 'T', 'West'), ('Marlen', 'W', 'Anderson'), ('Angeline', 'H', 'Huel')]", "exec_match": true}
{"db_id": "e_commerce", "question": "WHat are the first and last names, and middle initials of all customers who did not make any orders?", "query": "SELECT customer_first_name ,  customer_middle_initial ,  customer_last_name FROM Customers EXCEPT SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id", "predict": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_id IS NULL;", "llm_explanation": "This SQL query selects the first name, middle initial, and last name of customers from the 'customers' table. It uses a LEFT JOIN with the 'orders' table to find all customers who have no corresponding entries in the 'orders' table, indicating they have not made any orders. The condition 'o.order_id IS NULL' ensures that only customers without orders are included in the results.", "gold_exec_result": "[('Angeline', 'H', 'Huel'), ('David', 'T', 'West'), ('Jailyn', 'C', 'Murray'), ('Marlen', 'W', 'Anderson')]", "predict_exec_result": "[('Jailyn', 'C', 'Murray'), ('David', 'T', 'West'), ('Marlen', 'W', 'Anderson'), ('Angeline', 'H', 'Huel')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the id, name, price and color of the products which have not been ordered for at least twice?", "query": "SELECT product_id ,  product_name ,  product_price ,  product_color FROM Products EXCEPT SELECT T1.product_id ,  T1.product_name ,  T1.product_price ,  T1.product_color FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.product_id HAVING count(*)  >=  2", "predict": "SELECT p.product_id, p.product_name, p.product_price, p.product_color FROM products p WHERE (SELECT COUNT(*) FROM order_items oi WHERE oi.product_id = p.product_id) < 2;", "llm_explanation": "This SQL query selects the id, name, price, and color of products from the 'products' table. It uses a subquery to count the number of times each product appears in the 'order_items' table. The main query filters out products that have been ordered fewer than twice, ensuring only those with zero or one order are included.", "gold_exec_result": "[(2, 'Dell keyboard', 104, 'Yellow')]", "predict_exec_result": "[(2, 'Dell keyboard', 104, 'Yellow')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the ids , names , prices , and colors of all products that have been listed in less than two orders ?", "query": "select t1.product_id ,  t1.product_name ,  t1.product_price ,  t1.product_color from products as t1 join order_items as t2 on t1.product_id  =  t2.product_id join orders as t3 on t2.order_id  =  t3.order_id group by t1.product_id having count(*) < 2", "predict": "SELECT p.product_id, p.product_name, p.product_price, p.product_color FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id HAVING COUNT(oi.order_id) < 2", "llm_explanation": "This SQL query selects the product ID, name, price, and color from the 'products' table. It joins the 'order_items' table to count the number of orders each product appears in. The 'GROUP BY' clause groups the results by product ID, and the 'HAVING' clause filters out products that appear in two or more orders, ensuring only products listed in less than two orders are included.", "gold_exec_result": "[(2, 'Dell keyboard', 104, 'Yellow')]", "predict_exec_result": "[(2, 'Dell keyboard', 104, 'Yellow')]", "exec_match": true}
{"db_id": "e_commerce", "question": "Which orders have at least 2 products on it? List the order id and date.", "query": "SELECT T1.order_id ,  T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >=  2", "predict": "SELECT o.order_id, o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id HAVING COUNT(oi.product_id) >= 2", "llm_explanation": "This SQL query selects the order ID and date from the 'orders' table. It joins the 'order_items' table to count the number of products per order. The GROUP BY clause groups the results by order ID, and the HAVING clause filters out orders with fewer than 2 products.", "gold_exec_result": "[(3, '2017-09-10 08:27:04'), (10, '2017-09-25 14:30:23'), (18, '2017-05-15 15:13:44'), (19, '2017-12-10 23:45:42')]", "predict_exec_result": "[(3, '2017-09-10 08:27:04'), (10, '2017-09-25 14:30:23'), (18, '2017-05-15 15:13:44'), (19, '2017-12-10 23:45:42')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the ids and dates of the orders with at least two products?", "query": "SELECT T1.order_id ,  T1.date_order_placed FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id GROUP BY T1.order_id HAVING count(*)  >=  2", "predict": "SELECT o.order_id, o.date_order_placed FROM orders o JOIN order_items oi ON o.order_id = oi.order_id GROUP BY o.order_id HAVING COUNT(oi.product_id) >= 2", "llm_explanation": "This SQL query retrieves the order IDs and their corresponding dates from the 'orders' table where each order has at least two products. It achieves this by joining the 'orders' table with the 'order_items' table on the 'order_id' column, grouping the results by 'order_id', and using the HAVING clause to filter groups that have a count of 'product_id' greater than or equal to 2.", "gold_exec_result": "[(3, '2017-09-10 08:27:04'), (10, '2017-09-25 14:30:23'), (18, '2017-05-15 15:13:44'), (19, '2017-12-10 23:45:42')]", "predict_exec_result": "[(3, '2017-09-10 08:27:04'), (10, '2017-09-25 14:30:23'), (18, '2017-05-15 15:13:44'), (19, '2017-12-10 23:45:42')]", "exec_match": true}
{"db_id": "e_commerce", "question": "Which product are listed in orders most frequently? List the id, product name and price.", "query": "SELECT T1.product_id ,  T1.product_name ,  T1.product_price FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT p.product_id, p.product_name, p.product_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id ORDER BY COUNT(oi.order_item_id) DESC LIMIT 1;", "llm_explanation": "This SQL query joins the 'products' and 'order_items' tables on the 'product_id' column to count how frequently each product appears in orders. It groups the results by 'product_id' and orders them by the count of 'order_item_id' in descending order, selecting the top product with the highest frequency. The query returns the 'product_id', 'product_name', and 'product_price' of the most frequently ordered product.", "gold_exec_result": "[(3, 'iPhone6s', 560.93)]", "predict_exec_result": "[(3, 'iPhone6s', 560.93)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the ids, names, and prices of all products that are ordered most frequently?", "query": "SELECT T1.product_id ,  T1.product_name ,  T1.product_price FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT p.product_id, p.product_name, p.product_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id ORDER BY COUNT(oi.order_item_id) DESC LIMIT 1;", "llm_explanation": "This SQL query retrieves the IDs, names, and prices of the most frequently ordered products. It joins the 'products' table with the 'order_items' table on the product ID, groups the results by product ID, and orders them by the count of order items in descending order. The 'LIMIT 1' ensures only the most frequently ordered product is returned.", "gold_exec_result": "[(3, 'iPhone6s', 560.93)]", "predict_exec_result": "[(3, 'iPhone6s', 560.93)]", "exec_match": true}
{"db_id": "e_commerce", "question": "Which order have the least sum of the product prices. List the order id and sum.", "query": "SELECT T1.order_id ,  sum(T2.product_price) FROM Order_items AS T1 JOIN Products AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.order_id ORDER BY sum(T2.product_price) ASC LIMIT 1", "predict": "SELECT o.order_id, SUM(p.product_price) AS total_price FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id ORDER BY total_price ASC LIMIT 1", "llm_explanation": "This SQL query joins the 'orders', 'order_items', and 'products' tables to calculate the sum of product prices for each order. It groups the results by 'order_id' and orders them by the total price in ascending order. The 'LIMIT 1' clause ensures that only the order with the least sum of product prices is returned, along with its 'order_id' and the corresponding sum.", "gold_exec_result": "[(7, 104)]", "predict_exec_result": "[(7, 104)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What is the order that total cost the least , and how much is the total cost ?", "query": "select t1.order_id ,  sum(t2.product_price) from order_items as t1 join products as t2 on t1.product_id  =  t2.product_id group by t1.order_id order by sum(t2.product_price) asc limit 1", "predict": "SELECT o.order_id, SUM(p.product_price) AS total_cost FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id ORDER BY total_cost ASC LIMIT 1;", "llm_explanation": "This SQL query finds the order with the least total cost by joining the 'orders', 'order_items', and 'products' tables. It calculates the total cost for each order by summing the 'product_price' of all items in the order. The results are grouped by 'order_id' and sorted in ascending order of 'total_cost'. The 'LIMIT 1' clause ensures that only the order with the lowest total cost is returned.", "gold_exec_result": "[(7, 104)]", "predict_exec_result": "[(7, 104)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What is the most popular payment method?", "query": "SELECT Payment_method_code FROM Customer_Payment_Methods GROUP BY Payment_method_code ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT `payment method code`, COUNT(*) AS count FROM `customer payment methods` GROUP BY `payment method code` ORDER BY count DESC LIMIT 1;", "llm_explanation": "This SQL query identifies the most popular payment method by counting the occurrences of each `payment method code` in the `customer payment methods` table. It groups the results by `payment method code`, orders them in descending order based on the count, and limits the result to the top one.", "gold_exec_result": "[('Credit Card',)]", "predict_exec_result": "no such table: customer payment methods", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the payment method that most customers use?", "query": "SELECT Payment_method_code FROM Customer_Payment_Methods GROUP BY Payment_method_code ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT `payment method code`, COUNT(*) AS usage_count FROM `customer payment methods` GROUP BY `payment method code` ORDER BY usage_count DESC LIMIT 1;", "llm_explanation": "This SQL query retrieves the most frequently used payment method by customers. It selects the `payment method code` from the `customer payment methods` table, counts the occurrences of each payment method, and orders the results in descending order based on the count. The `LIMIT 1` clause ensures that only the most used payment method is returned.", "gold_exec_result": "[('Credit Card',)]", "predict_exec_result": "no such table: customer payment methods", "exec_match": false}
{"db_id": "e_commerce", "question": "How many number of products does each gender of customers buy? List the gender and the number", "query": "SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.gender_code", "predict": "SELECT c.gender_code, COUNT(DISTINCT o.product_id) AS number_of_products           FROM customers c           JOIN orders o ON c.customer_id = o.customer_id           JOIN order_items oi ON o.order_id = oi.order_id           GROUP BY c.gender_code;", "llm_explanation": "This SQL query joins the 'customers', 'orders', and 'order_items' tables to count the number of unique products each gender of customers buys. The 'gender_code' from the 'customers' table is selected, and the count of distinct 'product_id' from the 'order_items' table is calculated for each gender. The results are grouped by 'gender_code' to get the count per gender.", "gold_exec_result": "[('Female', 2), ('Male', 12), ('Unknown', 1)]", "predict_exec_result": "no such column: o.product_id", "exec_match": false}
{"db_id": "e_commerce", "question": "How many products does each gender buy?", "query": "SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id GROUP BY T1.gender_code", "predict": "SELECT c.gender_code, COUNT(DISTINCT p.product_id) AS product_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY c.gender_code", "llm_explanation": "This SQL query joins the 'customers', 'orders', 'order_items', and 'products' tables to count the unique products bought by each gender. The 'GROUP BY' clause ensures the count is aggregated by gender code.", "gold_exec_result": "[('Female', 2), ('Male', 12), ('Unknown', 1)]", "predict_exec_result": "[('Female', 2), ('Male', 5), ('Unknown', 1)]", "exec_match": false}
{"db_id": "e_commerce", "question": "How many orders has each gender of customers placed?", "query": "SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.gender_code", "predict": "SELECT c.gender_code, COUNT(o.order_id) AS order_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.gender_code", "llm_explanation": "This SQL query joins the 'customers' and 'orders' tables on the 'customer_id' column to count the number of orders placed by each gender. The 'SELECT' statement retrieves the 'gender_code' from the 'customers' table and counts the 'order_id' from the 'orders' table, grouping the results by 'gender_code' to get the order count for each gender.", "gold_exec_result": "[('Female', 6), ('Male', 11), ('Unknown', 3)]", "predict_exec_result": "[('Female', 6), ('Male', 11), ('Unknown', 3)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many orders has each gender placed?", "query": "SELECT T1.gender_code ,  count(*) FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.gender_code", "predict": "SELECT c.gender_code, COUNT(o.order_id) AS order_count FROM customers c JOIN orders o ON c.customer_id = o.customer_id GROUP BY c.gender_code", "llm_explanation": "This SQL query joins the 'customers' and 'orders' tables on the 'customer_id' column to count the number of orders placed by each gender. The 'gender_code' column from the 'customers' table is selected, and the COUNT function is used to count the 'order_id' from the 'orders' table. The results are grouped by 'gender_code' to get the order count for each gender.", "gold_exec_result": "[('Female', 6), ('Male', 11), ('Unknown', 3)]", "predict_exec_result": "[('Female', 6), ('Male', 11), ('Unknown', 3)]", "exec_match": true}
{"db_id": "e_commerce", "question": "List the customers' first name, middle initial, last name and payment methods.", "query": "SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name ,  T2.Payment_method_code FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id", "predict": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name, pm.payment_method_code FROM customers c JOIN customer_payment_methods pm ON c.customer_id = pm.customer_id;", "llm_explanation": "The SQL query joins the 'customers' table with the 'customer_payment_methods' table using the 'customer_id' column to retrieve the first name, middle initial, last name from the 'customers' table and the payment method code from the 'customer_payment_methods' table. This ensures that we list the required customer details along with their payment methods.", "gold_exec_result": "[('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Carmen', 'K', 'Treutel', 'Direct Debit'), ('America', 'N', 'Nitzsche', 'Direct Debit'), ('Jamel', 'E', 'Koelpin', 'Credit Card'), ('David', 'T', 'West', 'Credit Card'), ('Rozella', 'S', 'Crooks', 'Credit Card'), ('Jamel', 'E', 'Koelpin', 'Cheque'), ('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Laurianne', 'C', 'Pfeffer', 'Credit Card'), ('Jailyn', 'C', 'Murray', 'Credit Card'), ('Zetta', 'S', 'Streich', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Cheque'), ('Vickie', 'B', 'Bergnaum', 'Credit Card'), ('Jace', 'P', 'Mraz', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Direct Debit')]", "predict_exec_result": "[('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Carmen', 'K', 'Treutel', 'Direct Debit'), ('America', 'N', 'Nitzsche', 'Direct Debit'), ('Jamel', 'E', 'Koelpin', 'Credit Card'), ('David', 'T', 'West', 'Credit Card'), ('Rozella', 'S', 'Crooks', 'Credit Card'), ('Jamel', 'E', 'Koelpin', 'Cheque'), ('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Laurianne', 'C', 'Pfeffer', 'Credit Card'), ('Jailyn', 'C', 'Murray', 'Credit Card'), ('Zetta', 'S', 'Streich', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Cheque'), ('Vickie', 'B', 'Bergnaum', 'Credit Card'), ('Jace', 'P', 'Mraz', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Direct Debit')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the first names, middle initials, last names, and payment methods of all customers?", "query": "SELECT T1.customer_first_name ,  T1.customer_middle_initial ,  T1.customer_last_name ,  T2.Payment_method_code FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id", "predict": "SELECT c.customer_first_name, c.customer_middle_initial, c.customer_last_name, p.payment_method_code FROM customers c JOIN customer_payment_methods p ON c.customer_id = p.customer_id", "llm_explanation": "The SQL query selects the first name, middle initial, and last name from the 'customers' table and the payment method code from the 'customer_payment_methods' table. It uses an INNER JOIN to combine rows from both tables where the customer IDs match, ensuring that only customers with payment methods are included in the results.", "gold_exec_result": "[('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Carmen', 'K', 'Treutel', 'Direct Debit'), ('America', 'N', 'Nitzsche', 'Direct Debit'), ('Jamel', 'E', 'Koelpin', 'Credit Card'), ('David', 'T', 'West', 'Credit Card'), ('Rozella', 'S', 'Crooks', 'Credit Card'), ('Jamel', 'E', 'Koelpin', 'Cheque'), ('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Laurianne', 'C', 'Pfeffer', 'Credit Card'), ('Jailyn', 'C', 'Murray', 'Credit Card'), ('Zetta', 'S', 'Streich', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Cheque'), ('Vickie', 'B', 'Bergnaum', 'Credit Card'), ('Jace', 'P', 'Mraz', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Direct Debit')]", "predict_exec_result": "[('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Carmen', 'K', 'Treutel', 'Direct Debit'), ('America', 'N', 'Nitzsche', 'Direct Debit'), ('Jamel', 'E', 'Koelpin', 'Credit Card'), ('David', 'T', 'West', 'Credit Card'), ('Rozella', 'S', 'Crooks', 'Credit Card'), ('Jamel', 'E', 'Koelpin', 'Cheque'), ('Carmine', 'A', 'Steuber', 'Direct Debit'), ('Laurianne', 'C', 'Pfeffer', 'Credit Card'), ('Jailyn', 'C', 'Murray', 'Credit Card'), ('Zetta', 'S', 'Streich', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Cheque'), ('Vickie', 'B', 'Bergnaum', 'Credit Card'), ('Jace', 'P', 'Mraz', 'Credit Card'), ('Angeline', 'H', 'Huel', 'Direct Debit')]", "exec_match": true}
{"db_id": "e_commerce", "question": "List the invoices' status, date and the date of shipment.", "query": "SELECT T1.invoice_status_code ,  T1.invoice_date ,  T2.shipment_date FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number", "predict": "SELECT invoices.invoice_status_code, invoices.invoice_date, shipments.shipment_date FROM invoices JOIN shipments ON invoices.invoice_number = shipments.invoice_number;", "llm_explanation": "The query selects the invoice status, invoice date, and shipment date by joining the 'invoices' and 'shipments' tables on the 'invoice_number' column. This ensures that the dates and statuses are correctly matched for each invoice.", "gold_exec_result": "[('Paid', '2018-03-14 11:58:55', '2018-02-28 00:04:11'), ('Issued', '2018-01-28 20:08:22', '2018-03-07 01:57:14'), ('Issued', '2018-03-11 02:04:42', '2018-03-18 22:23:19'), ('Paid', '2018-03-23 17:12:08', '2018-03-11 23:48:37'), ('Issued', '2018-02-17 13:52:46', '2018-02-25 21:42:52'), ('Issued', '2018-02-03 05:46:16', '2018-03-15 01:10:18'), ('Paid', '2018-02-13 02:16:55', '2018-03-14 16:21:03'), ('Paid', '2018-03-14 11:58:55', '2018-03-12 01:44:44'), ('Paid', '2018-02-14 02:48:48', '2018-03-20 01:23:34'), ('Issued', '2018-01-26 02:23:32', '2018-03-16 03:30:05'), ('Issued', '2018-01-28 20:08:22', '2018-02-25 19:24:52'), ('Issued', '2018-01-26 02:23:32', '2018-03-20 21:01:04'), ('Issued', '2018-02-17 13:52:46', '2018-03-25 15:37:44'), ('Issued', '2018-03-04 18:54:34', '2018-03-10 22:34:34'), ('Issued', '2018-03-04 18:54:34', '2018-03-09 07:24:28')]", "predict_exec_result": "[('Paid', '2018-03-14 11:58:55', '2018-02-28 00:04:11'), ('Issued', '2018-01-28 20:08:22', '2018-03-07 01:57:14'), ('Issued', '2018-03-11 02:04:42', '2018-03-18 22:23:19'), ('Paid', '2018-03-23 17:12:08', '2018-03-11 23:48:37'), ('Issued', '2018-02-17 13:52:46', '2018-02-25 21:42:52'), ('Issued', '2018-02-03 05:46:16', '2018-03-15 01:10:18'), ('Paid', '2018-02-13 02:16:55', '2018-03-14 16:21:03'), ('Paid', '2018-03-14 11:58:55', '2018-03-12 01:44:44'), ('Paid', '2018-02-14 02:48:48', '2018-03-20 01:23:34'), ('Issued', '2018-01-26 02:23:32', '2018-03-16 03:30:05'), ('Issued', '2018-01-28 20:08:22', '2018-02-25 19:24:52'), ('Issued', '2018-01-26 02:23:32', '2018-03-20 21:01:04'), ('Issued', '2018-02-17 13:52:46', '2018-03-25 15:37:44'), ('Issued', '2018-03-04 18:54:34', '2018-03-10 22:34:34'), ('Issued', '2018-03-04 18:54:34', '2018-03-09 07:24:28')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the statuses, dates, and shipment dates for all invoices?", "query": "SELECT T1.invoice_status_code ,  T1.invoice_date ,  T2.shipment_date FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number", "predict": "SELECT i.invoice_status_code, i.invoice_date, s.shipment_date FROM invoices i LEFT JOIN shipments s ON i.invoice_number = s.invoice_number;", "llm_explanation": "This SQL query selects the invoice status code, invoice date, and shipment date from the 'invoices' and 'shipments' tables. It uses a LEFT JOIN to ensure all invoices are included even if they don't have a corresponding shipment. The join condition is based on the invoice number, which is a common field in both tables.", "gold_exec_result": "[('Paid', '2018-03-14 11:58:55', '2018-02-28 00:04:11'), ('Issued', '2018-01-28 20:08:22', '2018-03-07 01:57:14'), ('Issued', '2018-03-11 02:04:42', '2018-03-18 22:23:19'), ('Paid', '2018-03-23 17:12:08', '2018-03-11 23:48:37'), ('Issued', '2018-02-17 13:52:46', '2018-02-25 21:42:52'), ('Issued', '2018-02-03 05:46:16', '2018-03-15 01:10:18'), ('Paid', '2018-02-13 02:16:55', '2018-03-14 16:21:03'), ('Paid', '2018-03-14 11:58:55', '2018-03-12 01:44:44'), ('Paid', '2018-02-14 02:48:48', '2018-03-20 01:23:34'), ('Issued', '2018-01-26 02:23:32', '2018-03-16 03:30:05'), ('Issued', '2018-01-28 20:08:22', '2018-02-25 19:24:52'), ('Issued', '2018-01-26 02:23:32', '2018-03-20 21:01:04'), ('Issued', '2018-02-17 13:52:46', '2018-03-25 15:37:44'), ('Issued', '2018-03-04 18:54:34', '2018-03-10 22:34:34'), ('Issued', '2018-03-04 18:54:34', '2018-03-09 07:24:28')]", "predict_exec_result": "[('Paid', '2018-03-09 07:16:07', None), ('Issued', '2018-01-28 20:08:22', '2018-02-25 19:24:52'), ('Issued', '2018-01-28 20:08:22', '2018-03-07 01:57:14'), ('Paid', '2018-02-13 02:16:55', '2018-03-14 16:21:03'), ('Issued', '2018-03-11 02:04:42', '2018-03-18 22:23:19'), ('Paid', '2018-03-14 11:58:55', '2018-02-28 00:04:11'), ('Paid', '2018-03-14 11:58:55', '2018-03-12 01:44:44'), ('Paid', '2018-02-19 22:12:45', None), ('Paid', '2018-02-14 02:48:48', '2018-03-20 01:23:34'), ('Paid', '2018-03-20 00:29:12', None), ('Issued', '2018-02-17 13:52:46', '2018-02-25 21:42:52'), ('Issued', '2018-02-17 13:52:46', '2018-03-25 15:37:44'), ('Issued', '2018-02-17 11:18:32', None), ('Issued', '2018-03-04 18:54:34', '2018-03-09 07:24:28'), ('Issued', '2018-03-04 18:54:34', '2018-03-10 22:34:34'), ('Paid', '2018-03-05 20:09:18', None), ('Issued', '2018-01-26 02:23:32', '2018-03-16 03:30:05'), ('Issued', '2018-01-26 02:23:32', '2018-03-20 21:01:04'), ('Paid', '2018-03-23 17:12:08', '2018-03-11 23:48:37'), ('Issued', '2018-02-03 05:46:16', '2018-03-15 01:10:18')]", "exec_match": false}
{"db_id": "e_commerce", "question": "List the names of the products being shipped and the corresponding shipment date.", "query": "SELECT T1.product_name ,  T4.shipment_date FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id", "predict": "SELECT p.product_name, s.shipment_date FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id", "llm_explanation": "This SQL query retrieves the product names and shipment dates by joining three tables: 'products', 'order_items', and 'shipments'. The 'products' table provides the product names, the 'order_items' table links products to orders, and the 'shipments' table provides the shipment dates. The joins ensure that only products that are part of an order and have a corresponding shipment are listed.", "gold_exec_result": "[('Dell monitor', '2018-03-11 23:48:37'), ('Dell monitor', '2018-03-14 16:21:03'), ('Lenovo keyboard', '2018-03-09 07:24:28'), ('Dell monitor', '2018-03-12 01:44:44'), ('iPhone6s', '2018-03-20 01:23:34'), ('Dell monitor', '2018-03-15 01:10:18')]", "predict_exec_result": "[('iWatch', '2018-03-11 23:48:37'), ('iPhone6s', '2018-03-16 03:30:05'), ('Dell keyboard', '2018-02-28 00:04:11'), ('Dell keyboard', '2018-03-25 15:37:44'), ('Dell monitor', '2018-03-20 01:23:34'), ('Lenovo keyboard', '2018-03-20 01:23:34'), ('iPhone6s', '2018-02-25 19:24:52'), ('iPhone6s', '2018-03-07 01:57:14'), ('iPhone6s', '2018-03-09 07:24:28'), ('iWatch', '2018-03-20 21:01:04')]", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the names of the products tht have been shipped, and on what days were they shipped?", "query": "SELECT T1.product_name ,  T4.shipment_date FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id", "predict": "SELECT p.product_name, s.shipment_date FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL;", "llm_explanation": "This SQL query retrieves the names of products that have been shipped and the corresponding shipment dates. It joins the 'products' table with the 'order_items' table on the 'product_id' to find which products are in orders, and then joins the 'shipments' table on the 'order_id' to filter only those orders that have been shipped. The WHERE clause ensures that only records with a non-null shipment date are included, indicating that the product has indeed been shipped.", "gold_exec_result": "[('Dell monitor', '2018-03-11 23:48:37'), ('Dell monitor', '2018-03-14 16:21:03'), ('Lenovo keyboard', '2018-03-09 07:24:28'), ('Dell monitor', '2018-03-12 01:44:44'), ('iPhone6s', '2018-03-20 01:23:34'), ('Dell monitor', '2018-03-15 01:10:18')]", "predict_exec_result": "[('iWatch', '2018-03-11 23:48:37'), ('iPhone6s', '2018-03-16 03:30:05'), ('Dell keyboard', '2018-02-28 00:04:11'), ('Dell keyboard', '2018-03-25 15:37:44'), ('Dell monitor', '2018-03-20 01:23:34'), ('Lenovo keyboard', '2018-03-20 01:23:34'), ('iPhone6s', '2018-02-25 19:24:52'), ('iPhone6s', '2018-03-07 01:57:14'), ('iPhone6s', '2018-03-09 07:24:28'), ('iWatch', '2018-03-20 21:01:04')]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the status code of the items being ordered and shipped and its corresponding shipment tracking number?", "query": "SELECT T1.order_item_status_code ,  T3.shipment_tracking_number FROM Order_items AS T1 JOIN Shipment_Items AS T2 ON T1.order_item_id  =  T2.order_item_id JOIN Shipments AS T3 ON T2.shipment_id  =  T3.shipment_id", "predict": "SELECT o.order_status_code, s.shipment_tracking_number FROM orders o JOIN shipments s ON o.order_id = s.order_id WHERE o.order_status_code = 'shipped';", "llm_explanation": "This SQL query retrieves the order status code and shipment tracking number for items that are being ordered and shipped. It joins the 'orders' table with the 'shipments' table on the 'order_id' column to link orders with their corresponding shipments. The WHERE clause filters the results to include only those orders with a status code of 'shipped'.", "gold_exec_result": "[('Out of Stock', '6074'), ('Out of Stock', '8731'), ('Out of Stock', '5506'), ('Out of Stock', '6804'), ('Out of Stock', '4377'), ('Out of Stock', '3335')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the status code of the items have been ordered and shipped, and also what are their shipment tracking numbers?", "query": "SELECT T1.order_item_status_code ,  T3.shipment_tracking_number FROM Order_items AS T1 JOIN Shipment_Items AS T2 ON T1.order_item_id  =  T2.order_item_id JOIN Shipments AS T3 ON T2.shipment_id  =  T3.shipment_id", "predict": "SELECT o.order_status_code, s.shipment_tracking_number FROM orders o JOIN shipments s ON o.order_id = s.order_id WHERE o.order_status_code = 'shipped';", "llm_explanation": "This SQL query retrieves the order status code and shipment tracking number for items that have been ordered and shipped. It joins the 'orders' and 'shipments' tables on the 'order_id' column, filtering to include only rows where the 'order_status_code' is 'shipped'. This ensures that the results include only those items that meet the specified criteria.", "gold_exec_result": "[('Out of Stock', '6074'), ('Out of Stock', '8731'), ('Out of Stock', '5506'), ('Out of Stock', '6804'), ('Out of Stock', '4377'), ('Out of Stock', '3335')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the product name and the color of the ordered items which have been shipped?", "query": "SELECT T1.product_name ,  T1.product_color FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id", "predict": "SELECT p.product_name, p.product_color FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL", "llm_explanation": "This SQL query retrieves the product name and color from the 'products' table. It joins the 'order_items' table to link products with their respective orders, and then joins the 'shipments' table to filter only those orders that have been shipped (i.e., where 'shipment_date' is not null). This ensures that the results include only the ordered items that have been shipped.", "gold_exec_result": "[('Dell monitor', 'Red'), ('Dell monitor', 'Red'), ('Lenovo keyboard', 'Yellow'), ('Dell monitor', 'Red'), ('iPhone6s', 'Red'), ('Dell monitor', 'Red')]", "predict_exec_result": "[('iWatch', 'Red'), ('iPhone6s', 'Red'), ('Dell keyboard', 'Yellow'), ('Dell keyboard', 'Yellow'), ('Dell monitor', 'Red'), ('Lenovo keyboard', 'Yellow'), ('iPhone6s', 'Red'), ('iPhone6s', 'Red'), ('iPhone6s', 'Red'), ('iWatch', 'Red')]", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the names and colors of all products that have been shipped?", "query": "SELECT T1.product_name ,  T1.product_color FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Shipment_Items AS T3 ON T2.order_item_id  =  T3.order_item_id JOIN Shipments AS T4 ON T3.shipment_id  =  T4.shipment_id", "predict": "SELECT p.product_name, p.product_color FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL;", "llm_explanation": "This SQL query retrieves the names and colors of all products that have been shipped. It joins the 'products' table with the 'order_items' table on the 'product_id' to find which products are in orders. Then, it joins the resulting table with the 'shipments' table on the 'order_id' to filter out only those products that have a shipment record (i.e., 'shipment_date' is not null).", "gold_exec_result": "[('Dell monitor', 'Red'), ('Dell monitor', 'Red'), ('Lenovo keyboard', 'Yellow'), ('Dell monitor', 'Red'), ('iPhone6s', 'Red'), ('Dell monitor', 'Red')]", "predict_exec_result": "[('iWatch', 'Red'), ('iPhone6s', 'Red'), ('Dell keyboard', 'Yellow'), ('Dell keyboard', 'Yellow'), ('Dell monitor', 'Red'), ('Lenovo keyboard', 'Yellow'), ('iPhone6s', 'Red'), ('iPhone6s', 'Red'), ('iPhone6s', 'Red'), ('iWatch', 'Red')]", "exec_match": false}
{"db_id": "e_commerce", "question": "List all the distinct product names, price and descriptions which are bought by female customers.", "query": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'", "predict": "SELECT DISTINCT p.product_name, p.product_price, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN customers c ON o.customer_id = c.customer_id WHERE c.gender_code = 'F'", "llm_explanation": "This SQL query retrieves distinct product names, prices, and descriptions for products bought by female customers. It joins the 'products', 'order_items', and 'orders' tables to link products with orders, and then joins the 'customers' table to filter by gender code 'F' for females. The DISTINCT keyword ensures unique product entries.", "gold_exec_result": "[('iPhone6s', 560.93, 'Second hand!'), ('iWatch', 369.11, 'Designed for sports!')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the different names, prices, and descriptions for all products bought by female customers?", "query": "SELECT DISTINCT T1.product_name ,  T1.product_price ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id JOIN Orders AS T3 ON T2.order_id  =  T3.order_id JOIN Customers AS T4 ON T3.customer_id  =  T4.customer_id WHERE T4.gender_code  =  'Female'", "predict": "SELECT DISTINCT p.product_name, p.product_price, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN orders o ON oi.order_id = o.order_id JOIN customers c ON o.customer_id = c.customer_id WHERE c.gender_code = 'F'", "llm_explanation": "This SQL query retrieves distinct product names, prices, and descriptions for products bought by female customers. It joins the 'products', 'order_items', and 'orders' tables to link products with orders, and then joins the 'customers' table to filter by gender code 'F' for females. The DISTINCT keyword ensures unique product details are returned.", "gold_exec_result": "[('iPhone6s', 560.93, 'Second hand!'), ('iWatch', 369.11, 'Designed for sports!')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "What are invoices status of all the orders which have not been shipped?", "query": "SELECT invoice_status_code FROM Invoices WHERE invoice_number NOT IN ( SELECT invoice_number FROM Shipments )", "predict": "SELECT i.invoice_status_code FROM invoices i JOIN orders o ON i.invoice_number = o.invoice_number WHERE o.order_status_code != 'Shipped';", "llm_explanation": "This SQL query selects the invoice status code from the 'invoices' table for all orders that have not been shipped. It joins the 'invoices' table with the 'orders' table using the invoice number as the key. The WHERE clause filters out orders that have a status code indicating they have been shipped.", "gold_exec_result": "[('Paid',), ('Paid',), ('Paid',), ('Issued',), ('Paid',)]", "predict_exec_result": "no such column: o.invoice_number", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the invoice statuses for all orderes that have not been shipped out yet?", "query": "SELECT invoice_status_code FROM Invoices WHERE invoice_number NOT IN ( SELECT invoice_number FROM Shipments )", "predict": "SELECT DISTINCT i.invoice_status_code FROM invoices i JOIN orders o ON i.invoice_number = o.invoice_number WHERE o.order_status_code != 'Shipped'", "llm_explanation": "This SQL query selects distinct invoice statuses from the 'invoices' table for orders that have not been shipped yet. It joins the 'invoices' table with the 'orders' table on the invoice number and filters out orders with a status code of 'Shipped'.", "gold_exec_result": "[('Paid',), ('Paid',), ('Paid',), ('Issued',), ('Paid',)]", "predict_exec_result": "no such column: o.invoice_number", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the total cost of all the orders ? List the order id , date , and total cost .", "query": "select t1.order_id ,  t1.date_order_placed ,  sum(t3.product_price) from orders as t1 join order_items as t2 on t1.order_id  =  t2.order_id join products as t3 on t2.product_id  =  t3.product_id group by t1.order_id", "predict": "SELECT o.order_id, o.date_order_placed, SUM(p.product_price * oi.quantity) AS total_cost FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id, o.date_order_placed", "llm_explanation": "This SQL query retrieves the order ID and date from the 'orders' table, and calculates the total cost by summing the product of product price and quantity from the 'order_items' table. It joins 'orders' with 'order_items' on order ID and 'order_items' with 'products' on product ID, then groups the results by order ID and date to get the total cost per order.", "gold_exec_result": "[(1, '2017-09-17 16:13:07', 560.93), (3, '2017-09-10 08:27:04', 1178.29), (4, '2018-03-19 21:48:59', 560.93), (6, '2018-03-07 15:34:19', 560.93), (7, '2017-12-02 13:40:02', 104), (8, '2018-03-01 04:18:28', 369.11), (10, '2017-09-25 14:30:23', 1178.29), (17, '2017-10-27 11:27:07', 369.11), (18, '2017-05-15 15:13:44', 1178.29), (19, '2017-12-10 23:45:42', 1164.73), (20, '2017-09-20 22:18:50', 560.93)]", "predict_exec_result": "no such column: oi.quantity", "exec_match": false}
{"db_id": "e_commerce", "question": "For each order, what is its id, date, and total amount paid?", "query": "SELECT T1.order_id ,  T1.date_order_placed ,  sum(T3.product_price) FROM Orders AS T1 JOIN Order_items AS T2 ON T1.order_id  =  T2.order_id JOIN Products AS T3 ON T2.product_id  =  T3.product_id GROUP BY T1.order_id", "predict": "SELECT o.order_id, o.date_order_placed, SUM(p.product_price * oi.quantity) AS total_amount_paid FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id GROUP BY o.order_id", "llm_explanation": "The SQL query selects the order ID and date from the 'orders' table, calculates the total amount paid by summing the product of product price and quantity from the 'products' and 'order_items' tables, and groups the results by order ID.", "gold_exec_result": "[(1, '2017-09-17 16:13:07', 560.93), (3, '2017-09-10 08:27:04', 1178.29), (4, '2018-03-19 21:48:59', 560.93), (6, '2018-03-07 15:34:19', 560.93), (7, '2017-12-02 13:40:02', 104), (8, '2018-03-01 04:18:28', 369.11), (10, '2017-09-25 14:30:23', 1178.29), (17, '2017-10-27 11:27:07', 369.11), (18, '2017-05-15 15:13:44', 1178.29), (19, '2017-12-10 23:45:42', 1164.73), (20, '2017-09-20 22:18:50', 560.93)]", "predict_exec_result": "no such column: oi.quantity", "exec_match": false}
{"db_id": "e_commerce", "question": "How many customers have placed any order?", "query": "SELECT count(DISTINCT customer_id) FROM Orders", "predict": "SELECT COUNT(DISTINCT o.customer_id) FROM orders o", "llm_explanation": "This SQL query counts the number of unique customer IDs in the 'orders' table. The DISTINCT keyword ensures that each customer is counted only once, even if they have placed multiple orders. This gives the total number of customers who have placed at least one order.", "gold_exec_result": "[(11,)]", "predict_exec_result": "[(11,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many different customers have ordered things?", "query": "SELECT count(DISTINCT customer_id) FROM Orders", "predict": "SELECT COUNT(DISTINCT o.customer_id) FROM orders o", "llm_explanation": "To find the number of different customers who have ordered things, we use the COUNT(DISTINCT) function on the customer_id column from the orders table. This ensures that each customer is counted only once, even if they have placed multiple orders.", "gold_exec_result": "[(11,)]", "predict_exec_result": "[(11,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many item states are there in the orders?", "query": "SELECT count(DISTINCT order_item_status_code) FROM Order_items", "predict": "SELECT COUNT(DISTINCT order_item_status_code) FROM order_items", "llm_explanation": "To find the number of unique item states in the orders, we use the COUNT(DISTINCT) function on the 'order_item_status_code' column from the 'order_items' table. This SQL query will return the count of distinct item states, providing the desired information.", "gold_exec_result": "[(2,)]", "predict_exec_result": "[(2,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many different item status codes are there listed in ordered items?", "query": "SELECT count(DISTINCT order_item_status_code) FROM Order_items", "predict": "SELECT COUNT(DISTINCT \"order item status code\") FROM \"order items\"", "llm_explanation": "This SQL query counts the number of unique 'order item status code' values in the 'order items' table. The DISTINCT keyword ensures that each status code is counted only once, and the COUNT function tallies the total number of unique codes.", "gold_exec_result": "[(2,)]", "predict_exec_result": "no such table: order items", "exec_match": false}
{"db_id": "e_commerce", "question": "How many different payment methods are there?", "query": "SELECT count(DISTINCT Payment_method_code) FROM Customer_Payment_Methods", "predict": "SELECT COUNT(DISTINCT payment_method_code) FROM customer_payment_methods", "llm_explanation": "To find the number of different payment methods, we use the COUNT function with the DISTINCT keyword to count unique values in the 'payment_method_code' column from the 'customer_payment_methods' table.", "gold_exec_result": "[(3,)]", "predict_exec_result": "[(3,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many different payment methods can customers choose from?", "query": "SELECT count(DISTINCT Payment_method_code) FROM Customer_Payment_Methods", "predict": "SELECT COUNT(DISTINCT payment_method_code) FROM customer_payment_methods", "llm_explanation": "To find the number of different payment methods customers can choose from, we use the COUNT function with the DISTINCT keyword to count unique values in the 'payment_method_code' column from the 'customer_payment_methods' table.", "gold_exec_result": "[(3,)]", "predict_exec_result": "[(3,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the login names and passwords of the customers whose phone number have the prefix '+12'?", "query": "SELECT login_name ,  login_password FROM Customers WHERE phone_number LIKE '+12%'", "predict": "SELECT login_name, login_password FROM customers WHERE phone_number LIKE '+12%'", "llm_explanation": "This SQL query selects the login names and passwords from the 'customers' table where the phone number starts with '+12'. The 'LIKE' operator is used with the pattern '+12%' to match any phone number that begins with '+12'.", "gold_exec_result": "[('vwehner', '372350093217369391dd')]", "predict_exec_result": "[('vwehner', '372350093217369391dd')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the usernames and passwords of all customers whose phone number starts with '+12'?", "query": "SELECT login_name ,  login_password FROM Customers WHERE phone_number LIKE '+12%'", "predict": "SELECT login_name, login_password FROM customers WHERE phone_number LIKE '+12%'", "llm_explanation": "This SQL query selects the 'login_name' and 'login_password' columns from the 'customers' table. The WHERE clause filters the results to include only those rows where the 'phone_number' column starts with '+12'. The '%' symbol is a wildcard that matches any sequence of characters following '+12'.", "gold_exec_result": "[('vwehner', '372350093217369391dd')]", "predict_exec_result": "[('vwehner', '372350093217369391dd')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the product sizes of the products whose name has the substring 'Dell'?", "query": "SELECT product_size FROM Products WHERE product_name LIKE '%Dell%'", "predict": "SELECT DISTINCT `product size` FROM `products` WHERE `product name` LIKE '%Dell%';", "llm_explanation": "This SQL query selects the distinct product sizes from the 'products' table where the 'product name' column contains the substring 'Dell'. The 'LIKE' operator is used with the pattern '%Dell%' to match any product name that includes 'Dell' anywhere in the string. The 'DISTINCT' keyword ensures that only unique sizes are returned, avoiding duplicates.", "gold_exec_result": "[('Medium',), ('Medium',)]", "predict_exec_result": "no such column: product size", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the sizes of all products whose name includes the word 'Dell'?", "query": "SELECT product_size FROM Products WHERE product_name LIKE '%Dell%'", "predict": "SELECT DISTINCT `product size` FROM `products` WHERE `product name` LIKE '%Dell%';", "llm_explanation": "This SQL query selects the distinct sizes of products from the 'products' table where the product name includes the word 'Dell'. The 'LIKE' operator is used with the pattern '%Dell%' to match any product name containing 'Dell' anywhere in the string. The 'DISTINCT' keyword ensures that each size is listed only once, even if multiple products have the same size.", "gold_exec_result": "[('Medium',), ('Medium',)]", "predict_exec_result": "no such column: product size", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the product price and the product size of the products whose price is above average?", "query": "SELECT product_price ,  product_size FROM Products WHERE product_price  >  ( SELECT avg(product_price) FROM Products )", "predict": "SELECT product_price, product_size FROM products WHERE product_price > (SELECT AVG(product_price) FROM products)", "llm_explanation": "This SQL query selects the 'product_price' and 'product_size' columns from the 'products' table. It filters the results to include only those products whose 'product_price' is greater than the average product price calculated from the same 'products' table. The subquery (SELECT AVG(product_price) FROM products) computes the average price, and the main query compares each product's price against this average.", "gold_exec_result": "[(795.62, 'Medium'), (560.93, 'Small')]", "predict_exec_result": "[(795.62, 'Medium'), (560.93, 'Small')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the prices and sizes of all products whose price is above the mean?", "query": "SELECT product_price ,  product_size FROM Products WHERE product_price  >  ( SELECT avg(product_price) FROM Products )", "predict": "SELECT product_price, product_size FROM products WHERE product_price > (SELECT AVG(product_price) FROM products)", "llm_explanation": "This SQL query selects the 'product_price' and 'product_size' columns from the 'products' table. It filters the results to include only those rows where the 'product_price' is greater than the average 'product_price' of all products in the table. The subquery (SELECT AVG(product_price) FROM products) calculates the mean price of all products, which is then used in the main query to filter the results.", "gold_exec_result": "[(795.62, 'Medium'), (560.93, 'Small')]", "predict_exec_result": "[(795.62, 'Medium'), (560.93, 'Small')]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many kinds of products have not been sold?", "query": "SELECT count(*) FROM Products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )", "predict": "SELECT COUNT(*) FROM products WHERE product_id NOT IN (SELECT product_id FROM order_items)", "llm_explanation": "This SQL query counts the number of products that have not been sold. It does this by selecting the count of all product IDs from the 'products' table that are not present in the 'product_id' column of the 'order_items' table. This indicates that these products have not been included in any orders, hence not sold.", "gold_exec_result": "[(0,)]", "predict_exec_result": "[(0,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What is the number of products that have not been ordered yet?", "query": "SELECT count(*) FROM Products WHERE product_id NOT IN ( SELECT product_id FROM Order_items )", "predict": "SELECT COUNT(*) FROM products WHERE product_id NOT IN (SELECT product_id FROM order_items)", "llm_explanation": "This SQL query counts the number of products that have not been ordered yet. It does this by selecting the count of all product IDs from the 'products' table where the product ID is not found in the 'product_id' column of the 'order_items' table. This effectively filters out all products that have been included in any order, leaving only those that have not been ordered.", "gold_exec_result": "[(0,)]", "predict_exec_result": "[(0,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many customers do not have any payment method?", "query": "SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payment_Methods )", "predict": "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer payment methods)", "llm_explanation": "This SQL query counts the number of customers who do not have any payment method. It first selects all customer IDs from the 'customers' table and then excludes those who have a corresponding entry in the 'customer payment methods' table.", "gold_exec_result": "[(3,)]", "predict_exec_result": "near \"methods\": syntax error", "exec_match": false}
{"db_id": "e_commerce", "question": "How many customers do not have a listed payment method?", "query": "SELECT count(*) FROM Customers WHERE customer_id NOT IN ( SELECT customer_id FROM Customer_Payment_Methods )", "predict": "SELECT COUNT(*) FROM customers WHERE customer_id NOT IN (SELECT customer_id FROM customer_payment_methods)", "llm_explanation": "This SQL query counts the number of customers who do not have a listed payment method. It first selects all customer IDs from the 'customers' table, then filters out those who have a corresponding entry in the 'customer_payment_methods' table, ensuring only customers without a payment method are counted.", "gold_exec_result": "[(3,)]", "predict_exec_result": "[(3,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are all the order status and all the dates of orders?", "query": "SELECT order_status_code ,  date_order_placed FROM Orders", "predict": "SELECT DISTINCT order_status_code, date_order_placed FROM orders;", "llm_explanation": "The SQL query selects distinct values of 'order_status_code' and 'date_order_placed' from the 'orders' table. This ensures that all unique order statuses and their corresponding dates are retrieved, providing a comprehensive list of order statuses and the dates on which orders were placed.", "gold_exec_result": "[('Cancelled', '2017-09-17 16:13:07'), ('Part Completed', '2017-10-14 12:05:48'), ('Cancelled', '2017-09-10 08:27:04'), ('Delivered', '2018-03-19 21:48:59'), ('Delivered', '2017-09-17 07:48:34'), ('Delivered', '2018-03-07 15:34:19'), ('Part Completed', '2017-12-02 13:40:02'), ('Part Completed', '2018-03-01 04:18:28'), ('Part Completed', '2018-03-01 05:25:55'), ('Part Completed', '2017-09-25 14:30:23'), ('Cancelled', '2017-05-27 10:55:13'), ('Cancelled', '2017-11-06 00:37:20'), ('Part Completed', '2017-09-26 06:53:48'), ('Delivered', '2017-05-02 00:04:13'), ('Cancelled', '2017-11-23 04:27:11'), ('Cancelled', '2017-07-19 12:45:12'), ('Delivered', '2017-10-27 11:27:07'), ('Cancelled', '2017-05-15 15:13:44'), ('Part Completed', '2017-12-10 23:45:42'), ('Cancelled', '2017-09-20 22:18:50')]", "predict_exec_result": "[('Cancelled', '2017-09-17 16:13:07'), ('Part Completed', '2017-10-14 12:05:48'), ('Cancelled', '2017-09-10 08:27:04'), ('Delivered', '2018-03-19 21:48:59'), ('Delivered', '2017-09-17 07:48:34'), ('Delivered', '2018-03-07 15:34:19'), ('Part Completed', '2017-12-02 13:40:02'), ('Part Completed', '2018-03-01 04:18:28'), ('Part Completed', '2018-03-01 05:25:55'), ('Part Completed', '2017-09-25 14:30:23'), ('Cancelled', '2017-05-27 10:55:13'), ('Cancelled', '2017-11-06 00:37:20'), ('Part Completed', '2017-09-26 06:53:48'), ('Delivered', '2017-05-02 00:04:13'), ('Cancelled', '2017-11-23 04:27:11'), ('Cancelled', '2017-07-19 12:45:12'), ('Delivered', '2017-10-27 11:27:07'), ('Cancelled', '2017-05-15 15:13:44'), ('Part Completed', '2017-12-10 23:45:42'), ('Cancelled', '2017-09-20 22:18:50')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the status codes and dates placed for all of the orders?", "query": "SELECT order_status_code ,  date_order_placed FROM Orders", "predict": "SELECT order_status_code, date_order_placed FROM orders;", "llm_explanation": "The query selects the 'order_status_code' and 'date_order_placed' columns from the 'orders' table. These columns correspond to the status codes and dates placed for all orders, respectively. The schema indicates that the 'orders' table contains these relevant columns, making this a straightforward SELECT query to retrieve the desired information.", "gold_exec_result": "[('Cancelled', '2017-09-17 16:13:07'), ('Part Completed', '2017-10-14 12:05:48'), ('Cancelled', '2017-09-10 08:27:04'), ('Delivered', '2018-03-19 21:48:59'), ('Delivered', '2017-09-17 07:48:34'), ('Delivered', '2018-03-07 15:34:19'), ('Part Completed', '2017-12-02 13:40:02'), ('Part Completed', '2018-03-01 04:18:28'), ('Part Completed', '2018-03-01 05:25:55'), ('Part Completed', '2017-09-25 14:30:23'), ('Cancelled', '2017-05-27 10:55:13'), ('Cancelled', '2017-11-06 00:37:20'), ('Part Completed', '2017-09-26 06:53:48'), ('Delivered', '2017-05-02 00:04:13'), ('Cancelled', '2017-11-23 04:27:11'), ('Cancelled', '2017-07-19 12:45:12'), ('Delivered', '2017-10-27 11:27:07'), ('Cancelled', '2017-05-15 15:13:44'), ('Part Completed', '2017-12-10 23:45:42'), ('Cancelled', '2017-09-20 22:18:50')]", "predict_exec_result": "[('Cancelled', '2017-09-17 16:13:07'), ('Part Completed', '2017-10-14 12:05:48'), ('Cancelled', '2017-09-10 08:27:04'), ('Delivered', '2018-03-19 21:48:59'), ('Delivered', '2017-09-17 07:48:34'), ('Delivered', '2018-03-07 15:34:19'), ('Part Completed', '2017-12-02 13:40:02'), ('Part Completed', '2018-03-01 04:18:28'), ('Part Completed', '2018-03-01 05:25:55'), ('Part Completed', '2017-09-25 14:30:23'), ('Cancelled', '2017-05-27 10:55:13'), ('Cancelled', '2017-11-06 00:37:20'), ('Part Completed', '2017-09-26 06:53:48'), ('Delivered', '2017-05-02 00:04:13'), ('Cancelled', '2017-11-23 04:27:11'), ('Cancelled', '2017-07-19 12:45:12'), ('Delivered', '2017-10-27 11:27:07'), ('Cancelled', '2017-05-15 15:13:44'), ('Part Completed', '2017-12-10 23:45:42'), ('Cancelled', '2017-09-20 22:18:50')]", "exec_match": true}
{"db_id": "e_commerce", "question": "List the address, town and county information of the customers who live in the USA.", "query": "SELECT address_line_1 ,  town_city ,  county FROM Customers WHERE Country  =  'USA'", "predict": "SELECT address_line_1, town_city, county FROM customers WHERE country = 'USA';", "llm_explanation": "The SQL query selects the columns 'address_line_1', 'town_city', and 'county' from the 'customers' table. The WHERE clause filters the results to include only those rows where the 'country' column equals 'USA', thus listing the address, town, and county information of customers who live in the USA.", "gold_exec_result": "[('646 Herzog Key Suite 702', 'Port Madonnahaven', 'Israel'), ('67899 Cassin Hollow Suite 071', 'Port Korychester', 'Palau'), ('395 Christophe Trail', 'Lornaland', 'Moldova'), ('14173 Alize Summit', 'Jennyferchester', 'Saint Vincent and the Grenadines'), ('69426 Lewis Estates Suite 438', 'Greenfelderberg', 'South Georgia and the South Sandwich Islands'), ('4672 Dwight Valleys Apt. 607', 'East Fritz', 'Afghanistan'), ('0933 Mozelle Junctions Suite 416', 'Cliftonberg', 'Reunion'), ('0629 Clotilde Mission', 'Ledaville', 'Bangladesh'), ('76015 Zelma Glen Apt. 194', 'Lake Claudiefort', 'Maldives'), ('983 Jamil Way Apt. 732', 'Braunland', 'Swaziland'), ('56465 Raymond Cliffs', 'North Kristybury', 'Iceland'), ('22704 Thompson Flat', 'West Polly', 'Martinique'), ('275 Blick Squares', 'Lake Zechariahton', 'Niue'), ('03217 Cummings Causeway', 'East Laura', 'Colombia'), ('9318 Hyatt Flats Apt. 999', 'Oletaside', 'Dominican Republic')]", "predict_exec_result": "[('646 Herzog Key Suite 702', 'Port Madonnahaven', 'Israel'), ('67899 Cassin Hollow Suite 071', 'Port Korychester', 'Palau'), ('395 Christophe Trail', 'Lornaland', 'Moldova'), ('14173 Alize Summit', 'Jennyferchester', 'Saint Vincent and the Grenadines'), ('69426 Lewis Estates Suite 438', 'Greenfelderberg', 'South Georgia and the South Sandwich Islands'), ('4672 Dwight Valleys Apt. 607', 'East Fritz', 'Afghanistan'), ('0933 Mozelle Junctions Suite 416', 'Cliftonberg', 'Reunion'), ('0629 Clotilde Mission', 'Ledaville', 'Bangladesh'), ('76015 Zelma Glen Apt. 194', 'Lake Claudiefort', 'Maldives'), ('983 Jamil Way Apt. 732', 'Braunland', 'Swaziland'), ('56465 Raymond Cliffs', 'North Kristybury', 'Iceland'), ('22704 Thompson Flat', 'West Polly', 'Martinique'), ('275 Blick Squares', 'Lake Zechariahton', 'Niue'), ('03217 Cummings Causeway', 'East Laura', 'Colombia'), ('9318 Hyatt Flats Apt. 999', 'Oletaside', 'Dominican Republic')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the addresses, towns, and county information for all customers who live in the United States?", "query": "SELECT address_line_1 ,  town_city ,  county FROM Customers WHERE Country  =  'USA'", "predict": "SELECT address_line_1, town_city, county FROM customers WHERE country = 'United States';", "llm_explanation": "This SQL query selects the columns 'address_line_1', 'town_city', and 'county' from the 'customers' table. The WHERE clause filters the results to include only those rows where the 'country' column is 'United States'. This ensures that the addresses, towns, and county information returned are for customers who live in the United States.", "gold_exec_result": "[('646 Herzog Key Suite 702', 'Port Madonnahaven', 'Israel'), ('67899 Cassin Hollow Suite 071', 'Port Korychester', 'Palau'), ('395 Christophe Trail', 'Lornaland', 'Moldova'), ('14173 Alize Summit', 'Jennyferchester', 'Saint Vincent and the Grenadines'), ('69426 Lewis Estates Suite 438', 'Greenfelderberg', 'South Georgia and the South Sandwich Islands'), ('4672 Dwight Valleys Apt. 607', 'East Fritz', 'Afghanistan'), ('0933 Mozelle Junctions Suite 416', 'Cliftonberg', 'Reunion'), ('0629 Clotilde Mission', 'Ledaville', 'Bangladesh'), ('76015 Zelma Glen Apt. 194', 'Lake Claudiefort', 'Maldives'), ('983 Jamil Way Apt. 732', 'Braunland', 'Swaziland'), ('56465 Raymond Cliffs', 'North Kristybury', 'Iceland'), ('22704 Thompson Flat', 'West Polly', 'Martinique'), ('275 Blick Squares', 'Lake Zechariahton', 'Niue'), ('03217 Cummings Causeway', 'East Laura', 'Colombia'), ('9318 Hyatt Flats Apt. 999', 'Oletaside', 'Dominican Republic')]", "predict_exec_result": "[]", "exec_match": false}
{"db_id": "e_commerce", "question": "List all the pairs of buyer first names and product names.", "query": "SELECT T1.customer_first_name ,  T4.product_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id JOIN Products AS T4 ON T3.product_id  =  T4.product_id", "predict": "SELECT c.customer_first_name, p.product_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id;", "llm_explanation": "This SQL query joins four tables: 'customers', 'orders', 'order_items', and 'products'. It selects the first name of the buyer from the 'customers' table and the product name from the 'products' table. The joins ensure that only relevant pairs of buyers and products are listed, based on the relationships defined by foreign keys in the schema.", "gold_exec_result": "[('Carmine', 'iWatch'), ('Sincere', 'iPhone6s'), ('Laurianne', 'Dell keyboard'), ('Carmine', 'Dell monitor'), ('Jamel', 'Dell monitor'), ('Vickie', 'Dell monitor'), ('Jamel', 'Lenovo keyboard'), ('Jamel', 'iWatch'), ('Vickie', 'Lenovo keyboard'), ('Rozella', 'iPhone6s'), ('Verner', 'iPhone6s'), ('Carmine', 'Lenovo keyboard'), ('Zetta', 'iWatch'), ('Jamel', 'Dell monitor'), ('America', 'iPhone6s')]", "predict_exec_result": "[('Carmine', 'iWatch'), ('Sincere', 'iPhone6s'), ('Laurianne', 'Dell keyboard'), ('Carmine', 'Dell monitor'), ('Jamel', 'Dell monitor'), ('Vickie', 'Dell monitor'), ('Jamel', 'Lenovo keyboard'), ('Jamel', 'iWatch'), ('Vickie', 'Lenovo keyboard'), ('Rozella', 'iPhone6s'), ('Verner', 'iPhone6s'), ('Carmine', 'Lenovo keyboard'), ('Zetta', 'iWatch'), ('Jamel', 'Dell monitor'), ('America', 'iPhone6s')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the first names of all buyers and what products did they buy? List them in pairs.", "query": "SELECT T1.customer_first_name ,  T4.product_name FROM Customers AS T1 JOIN Orders AS T2 ON T1.customer_id  =  T2.customer_id JOIN Order_items AS T3 ON T2.order_id  =  T3.order_id JOIN Products AS T4 ON T3.product_id  =  T4.product_id", "predict": "SELECT c.customer_first_name, p.product_name FROM customers c JOIN orders o ON c.customer_id = o.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id;", "llm_explanation": "This SQL query retrieves the first names of all buyers and the products they bought. It joins the 'customers', 'orders', 'order_items', and 'products' tables to link buyers with their purchased products. The 'JOIN' clauses ensure the correct relationships between tables based on foreign keys, and the 'SELECT' statement specifies the columns to display: 'customer_first_name' from the 'customers' table and 'product_name' from the 'products' table.", "gold_exec_result": "[('Carmine', 'iWatch'), ('Sincere', 'iPhone6s'), ('Laurianne', 'Dell keyboard'), ('Carmine', 'Dell monitor'), ('Jamel', 'Dell monitor'), ('Vickie', 'Dell monitor'), ('Jamel', 'Lenovo keyboard'), ('Jamel', 'iWatch'), ('Vickie', 'Lenovo keyboard'), ('Rozella', 'iPhone6s'), ('Verner', 'iPhone6s'), ('Carmine', 'Lenovo keyboard'), ('Zetta', 'iWatch'), ('Jamel', 'Dell monitor'), ('America', 'iPhone6s')]", "predict_exec_result": "[('Carmine', 'iWatch'), ('Sincere', 'iPhone6s'), ('Laurianne', 'Dell keyboard'), ('Carmine', 'Dell monitor'), ('Jamel', 'Dell monitor'), ('Vickie', 'Dell monitor'), ('Jamel', 'Lenovo keyboard'), ('Jamel', 'iWatch'), ('Vickie', 'Lenovo keyboard'), ('Rozella', 'iPhone6s'), ('Verner', 'iPhone6s'), ('Carmine', 'Lenovo keyboard'), ('Zetta', 'iWatch'), ('Jamel', 'Dell monitor'), ('America', 'iPhone6s')]", "exec_match": true}
{"db_id": "e_commerce", "question": "How many items are shipped?", "query": "SELECT count(*) FROM Shipment_Items", "predict": "SELECT COUNT(*) FROM `shipment items`", "llm_explanation": "To find the number of items shipped, we count the records in the 'shipment items' table. Each record in this table represents an item that has been shipped, so counting all records gives the total number of shipped items.", "gold_exec_result": "[(6,)]", "predict_exec_result": "no such table: shipment items", "exec_match": false}
{"db_id": "e_commerce", "question": "How many products have been shipped?", "query": "SELECT count(*) FROM Shipment_Items", "predict": "SELECT COUNT(DISTINCT p.product_id) FROM products p JOIN order_items oi ON p.product_id = oi.product_id JOIN shipments s ON oi.order_id = s.order_id WHERE s.shipment_date IS NOT NULL", "llm_explanation": "This SQL query counts the number of unique products that have been shipped. It joins the 'products' table with the 'order_items' table on the product ID, and then joins the resulting table with the 'shipments' table on the order ID. The query filters for records where the shipment date is not null, indicating that the product has been shipped, and then counts the distinct product IDs to avoid duplicates.", "gold_exec_result": "[(6,)]", "predict_exec_result": "[(5,)]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the product average price?", "query": "SELECT avg(product_price) FROM Products", "predict": "SELECT AVG(product_price) AS average_price FROM products", "llm_explanation": "This SQL query calculates the average price of products by using the AVG function on the 'product_price' column from the 'products' table. The result is aliased as 'average_price' for clarity.", "gold_exec_result": "[(442.466,)]", "predict_exec_result": "[(442.466,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "How much do the products cost on average?", "query": "SELECT avg(product_price) FROM Products", "predict": "SELECT AVG(product_price) AS average_product_price FROM products", "llm_explanation": "This SQL query calculates the average price of products by using the AVG function on the 'product_price' column from the 'products' table. The result is aliased as 'average_product_price' for clarity.", "gold_exec_result": "[(442.466,)]", "predict_exec_result": "[(442.466,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What is the average price of the products being ordered?", "query": "SELECT avg(T1.product_price) FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id", "predict": "SELECT AVG(p.product_price) AS average_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id", "llm_explanation": "To find the average price of the products being ordered, we need to join the 'products' table with the 'order_items' table using the 'product_id' column. The SQL query calculates the average of the 'product_price' column from the 'products' table, ensuring we only consider products that are linked to orders in the 'order_items' table.", "gold_exec_result": "[(519.036,)]", "predict_exec_result": "[(519.036,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What is the price of all products being ordered on average?", "query": "SELECT avg(T1.product_price) FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id", "predict": "SELECT AVG(p.product_price) AS average_price FROM products p JOIN order_items oi ON p.product_id = oi.product_id", "llm_explanation": "This SQL query calculates the average price of all products being ordered. It joins the 'products' table with the 'order_items' table on the 'product_id' column to ensure only products that are part of an order are considered. The AVG function is used to compute the average of the 'product_price' column from the 'products' table.", "gold_exec_result": "[(519.036,)]", "predict_exec_result": "[(519.036,)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the email address, town and county of the customers who are of the least common gender?", "query": "SELECT email_address ,  town_city ,  county FROM Customers WHERE gender_code  =  ( SELECT gender_code FROM Customers GROUP BY gender_code ORDER BY count(*) ASC LIMIT 1 )", "predict": "SELECT c.email_address, c.town_city, c.county FROM customers c WHERE c.gender_code = (SELECT gender_code FROM customers GROUP BY gender_code ORDER BY COUNT(*) ASC LIMIT 1)", "llm_explanation": "This SQL query retrieves the email address, town, and county of customers who belong to the least common gender. It uses a subquery to find the gender code with the smallest count in the customers table, then selects the relevant customer details where the gender code matches this least common gender.", "gold_exec_result": "[('gino.cruickshank@example.org', 'Braunland', 'Swaziland')]", "predict_exec_result": "[('gino.cruickshank@example.org', 'Braunland', 'Swaziland')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the email addresses, cities, and counties listed for all cusomters who are from the gender that orders less often?", "query": "SELECT email_address ,  town_city ,  county FROM Customers WHERE gender_code  =  ( SELECT gender_code FROM Customers GROUP BY gender_code ORDER BY count(*) ASC LIMIT 1 )", "predict": "SELECT c.email_address, c.town_city, c.county FROM customers c WHERE c.gender_code = (SELECT gender_code FROM orders o JOIN customers c ON o.customer_id = c.customer_id GROUP BY c.gender_code ORDER BY COUNT(o.order_id) ASC LIMIT 1)", "llm_explanation": "This SQL query retrieves the email addresses, cities, and counties of customers who belong to the gender that orders less frequently. It first identifies the gender with the fewest orders by grouping orders by gender and ordering by the count of orders in ascending order, then limits the result to the least frequent gender. Finally, it selects the required customer details from the customers table where the gender code matches the identified gender.", "gold_exec_result": "[('gino.cruickshank@example.org', 'Braunland', 'Swaziland')]", "predict_exec_result": "[('gino.cruickshank@example.org', 'Braunland', 'Swaziland')]", "exec_match": true}
{"db_id": "e_commerce", "question": "List the order date of the orders who are placed by customers with at least 2 payment methods.", "query": "SELECT date_order_placed FROM Orders WHERE customer_id IN ( SELECT T1.customer_id FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 )", "predict": "SELECT o.date_order_placed FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN customer_payment_methods cpm ON c.customer_id = cpm.customer_id GROUP BY o.customer_id HAVING COUNT(DISTINCT cpm.payment_method_code) >= 2", "llm_explanation": "This SQL query selects the order date from the 'orders' table. It joins the 'customers' table to link orders to customers and the 'customer_payment_methods' table to count payment methods per customer. The GROUP BY clause groups orders by customer ID, and the HAVING clause filters out customers with fewer than 2 distinct payment methods.", "gold_exec_result": "[('2017-10-14 12:05:48',), ('2017-09-10 08:27:04',), ('2018-03-01 04:18:28',), ('2017-09-25 14:30:23',), ('2017-12-10 23:45:42',)]", "predict_exec_result": "[('2017-10-14 12:05:48',)]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the date of all orders that have been placed by customers with at least 2 payment methods?", "query": "SELECT date_order_placed FROM Orders WHERE customer_id IN ( SELECT T1.customer_id FROM Customers AS T1 JOIN Customer_Payment_Methods AS T2 ON T1.customer_id  =  T2.customer_id GROUP BY T1.customer_id HAVING count(*)  >=  2 )", "predict": "SELECT o.date_order_placed FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN customer_payment_methods cpm ON c.customer_id = cpm.customer_id GROUP BY o.customer_id HAVING COUNT(DISTINCT cpm.payment_method_code) >= 2", "llm_explanation": "This SQL query retrieves the order dates from the 'orders' table for customers who have at least 2 different payment methods. It joins the 'orders' table with the 'customers' and 'customer_payment_methods' tables to link orders with customer payment methods. The GROUP BY clause groups the results by customer ID, and the HAVING clause filters out customers with fewer than 2 distinct payment methods.", "gold_exec_result": "[('2017-10-14 12:05:48',), ('2017-09-10 08:27:04',), ('2018-03-01 04:18:28',), ('2017-09-25 14:30:23',), ('2017-12-10 23:45:42',)]", "predict_exec_result": "[('2017-10-14 12:05:48',)]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the most uncommon order status?", "query": "SELECT order_status_code FROM Orders GROUP BY order_status_code ORDER BY count(*) LIMIT 1", "predict": "SELECT order_status_code, COUNT(*) as count FROM orders GROUP BY order_status_code ORDER BY count ASC LIMIT 1;", "llm_explanation": "This SQL query retrieves the most uncommon order status by grouping the 'orders' table by 'order_status_code' and counting the occurrences of each status. It then orders the results in ascending order of count and limits the output to the least common status. The 'order_status_code' column is used to identify different order statuses, and the COUNT(*) function counts how many times each status appears.", "gold_exec_result": "[('Delivered',)]", "predict_exec_result": "[('Delivered', 5)]", "exec_match": false}
{"db_id": "e_commerce", "question": "What is the least common order status?", "query": "SELECT order_status_code FROM Orders GROUP BY order_status_code ORDER BY count(*) LIMIT 1", "predict": "SELECT order_status_code, COUNT(*) as count FROM orders GROUP BY order_status_code ORDER BY count ASC LIMIT 1;", "llm_explanation": "This SQL query retrieves the least common order status from the 'orders' table. It groups the records by 'order_status_code', counts the occurrences of each status, and then orders the results in ascending order based on the count. The 'LIMIT 1' clause ensures that only the least common status is returned.", "gold_exec_result": "[('Delivered',)]", "predict_exec_result": "[('Delivered', 5)]", "exec_match": false}
{"db_id": "e_commerce", "question": "For all the products sold for more than 3 times, list their id and description.", "query": "SELECT T1.product_id ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id HAVING count(*)  >  3", "predict": "SELECT p.product_id, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id HAVING COUNT(oi.order_item_id) > 3", "llm_explanation": "This SQL query selects the product ID and description from the 'products' table. It joins the 'order_items' table on the product ID to count the number of times each product has been sold. The GROUP BY clause groups the results by product ID, and the HAVING clause filters out products that have been sold more than 3 times.", "gold_exec_result": "[(1, 'Latest model!'), (3, 'Second hand!')]", "predict_exec_result": "[(1, 'Latest model!'), (3, 'Second hand!')]", "exec_match": true}
{"db_id": "e_commerce", "question": "For all products sold more than 3 times, what are their ids and descriptions?", "query": "SELECT T1.product_id ,  T1.product_description FROM Products AS T1 JOIN Order_items AS T2 ON T1.product_id  =  T2.product_id GROUP BY T1.product_id HAVING count(*)  >  3", "predict": "SELECT p.product_id, p.product_description FROM products p JOIN order_items oi ON p.product_id = oi.product_id GROUP BY p.product_id HAVING COUNT(oi.order_item_id) > 3", "llm_explanation": "This SQL query selects the product ID and description from the 'products' table. It joins the 'order_items' table on the product ID to count the number of times each product has been sold. The GROUP BY clause groups the results by product ID, and the HAVING clause filters out products sold 3 times or fewer, ensuring only products sold more than 3 times are included in the results.", "gold_exec_result": "[(1, 'Latest model!'), (3, 'Second hand!')]", "predict_exec_result": "[(1, 'Latest model!'), (3, 'Second hand!')]", "exec_match": true}
{"db_id": "e_commerce", "question": "List the invoice dates and ids of the invoices causing at least 2 shipments.", "query": "SELECT T1.invoice_date ,  T1.invoice_number FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number HAVING count(*)  >=  2", "predict": "SELECT i.invoice_date, i.invoice_number FROM invoices i JOIN shipments s ON i.invoice_number = s.invoice_number GROUP BY i.invoice_number HAVING COUNT(s.shipment_id) >= 2;", "llm_explanation": "This SQL query selects the invoice date and invoice number from the 'invoices' table. It joins the 'shipments' table on the invoice number to count the number of shipments per invoice. The GROUP BY clause groups the results by invoice number, and the HAVING clause filters the results to include only those invoices with at least 2 shipments.", "gold_exec_result": "[('2018-01-28 20:08:22', 2), ('2018-03-14 11:58:55', 5), ('2018-02-17 13:52:46', 9), ('2018-03-04 18:54:34', 11), ('2018-01-26 02:23:32', 13)]", "predict_exec_result": "[('2018-01-28 20:08:22', 2), ('2018-03-14 11:58:55', 5), ('2018-02-17 13:52:46', 9), ('2018-03-04 18:54:34', 11), ('2018-01-26 02:23:32', 13)]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the dates and ids of the invoices that are related to at least 2 shipments?", "query": "SELECT T1.invoice_date ,  T1.invoice_number FROM Invoices AS T1 JOIN Shipments AS T2 ON T1.invoice_number  =  T2.invoice_number GROUP BY T1.invoice_number HAVING count(*)  >=  2", "predict": "SELECT i.invoice_date, i.invoice_number FROM invoices i JOIN shipments s ON i.invoice_number = s.invoice_number GROUP BY i.invoice_number HAVING COUNT(s.shipment_id) >= 2", "llm_explanation": "This SQL query selects the invoice date and invoice number from the 'invoices' table. It joins the 'shipments' table on the invoice number to find related shipments. The GROUP BY clause groups the results by invoice number, and the HAVING clause filters to include only those invoices with at least 2 related shipments.", "gold_exec_result": "[('2018-01-28 20:08:22', 2), ('2018-03-14 11:58:55', 5), ('2018-02-17 13:52:46', 9), ('2018-03-04 18:54:34', 11), ('2018-01-26 02:23:32', 13)]", "predict_exec_result": "[('2018-01-28 20:08:22', 2), ('2018-03-14 11:58:55', 5), ('2018-02-17 13:52:46', 9), ('2018-03-04 18:54:34', 11), ('2018-01-26 02:23:32', 13)]", "exec_match": true}
{"db_id": "e_commerce", "question": "what are all shipment tracking numbers and shipment dates?", "query": "SELECT shipment_tracking_number ,  shipment_date FROM Shipments", "predict": "SELECT `shipment tracking number`, `shipment date` FROM `shipments`;", "llm_explanation": "The query selects the columns 'shipment tracking number' and 'shipment date' from the 'shipments' table. These columns directly correspond to the information requested in the question. The table 'shipments' is identified from the schema where these columns are located.", "gold_exec_result": "[('6900', '2018-02-28 00:04:11'), ('3499', '2018-03-07 01:57:14'), ('5617', '2018-03-18 22:23:19'), ('6074', '2018-03-11 23:48:37'), ('3848', '2018-02-25 21:42:52'), ('3335', '2018-03-15 01:10:18'), ('8731', '2018-03-14 16:21:03'), ('6804', '2018-03-12 01:44:44'), ('4377', '2018-03-20 01:23:34'), ('8149', '2018-03-16 03:30:05'), ('9190', '2018-02-25 19:24:52'), ('9206', '2018-03-20 21:01:04'), ('4276', '2018-03-25 15:37:44'), ('9195', '2018-03-10 22:34:34'), ('5506', '2018-03-09 07:24:28')]", "predict_exec_result": "no such column: shipment tracking number", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the tracking numbers and dates for all shipments listed?", "query": "SELECT shipment_tracking_number ,  shipment_date FROM Shipments", "predict": "SELECT `shipment tracking number`, `shipment date` FROM `shipments`;", "llm_explanation": "The query selects the columns 'shipment tracking number' and 'shipment date' from the 'shipments' table. These columns correspond to the tracking numbers and dates for all shipments listed in the database. The schema indicates that the 'shipments' table contains these relevant fields, making this a straightforward selection query.", "gold_exec_result": "[('6900', '2018-02-28 00:04:11'), ('3499', '2018-03-07 01:57:14'), ('5617', '2018-03-18 22:23:19'), ('6074', '2018-03-11 23:48:37'), ('3848', '2018-02-25 21:42:52'), ('3335', '2018-03-15 01:10:18'), ('8731', '2018-03-14 16:21:03'), ('6804', '2018-03-12 01:44:44'), ('4377', '2018-03-20 01:23:34'), ('8149', '2018-03-16 03:30:05'), ('9190', '2018-02-25 19:24:52'), ('9206', '2018-03-20 21:01:04'), ('4276', '2018-03-25 15:37:44'), ('9195', '2018-03-10 22:34:34'), ('5506', '2018-03-09 07:24:28')]", "predict_exec_result": "no such column: shipment tracking number", "exec_match": false}
{"db_id": "e_commerce", "question": "What are the color, description and size of the products priced below the maximum price.", "query": "SELECT product_color ,  product_description ,  product_size FROM Products WHERE product_price  <  ( SELECT max(product_price) FROM products )", "predict": "SELECT product_color, product_description, product_size FROM products WHERE product_price < (SELECT MAX(product_price) FROM products);", "llm_explanation": "This SQL query selects the color, description, and size of products from the 'products' table where the product price is less than the maximum product price in the same table. The subquery (SELECT MAX(product_price) FROM products) calculates the maximum price, and the main query filters products below this price.", "gold_exec_result": "[('Yellow', 'Keyboard for games!', 'Medium'), ('Red', 'Second hand!', 'Small'), ('Red', 'Designed for sports!', 'Medium'), ('Yellow', 'Work smartly!', 'Medium')]", "predict_exec_result": "[('Yellow', 'Keyboard for games!', 'Medium'), ('Red', 'Second hand!', 'Small'), ('Red', 'Designed for sports!', 'Medium'), ('Yellow', 'Work smartly!', 'Medium')]", "exec_match": true}
{"db_id": "e_commerce", "question": "What are the colors , descriptions , and sizes for all products that are not at the maximum price ?", "query": "select product_color ,  product_description ,  product_size from products where product_price  !=  ( select max(product_price) from products )", "predict": "SELECT product_color, product_description, product_size FROM products WHERE product_price < (SELECT MAX(product_price) FROM products);", "llm_explanation": "This SQL query selects the columns 'product_color', 'product_description', and 'product_size' from the 'products' table. It filters the results to include only those rows where the 'product_price' is less than the maximum 'product_price' in the 'products' table. This ensures that products at the maximum price are excluded, as per the question's requirement.", "gold_exec_result": "[('Yellow', 'Keyboard for games!', 'Medium'), ('Red', 'Second hand!', 'Small'), ('Red', 'Designed for sports!', 'Medium'), ('Yellow', 'Work smartly!', 'Medium')]", "predict_exec_result": "[('Yellow', 'Keyboard for games!', 'Medium'), ('Red', 'Second hand!', 'Small'), ('Red', 'Designed for sports!', 'Medium'), ('Yellow', 'Work smartly!', 'Medium')]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Return the names of directors who are older than the average age.", "query": "SELECT name FROM director WHERE age  >  (SELECT avg(age) FROM director)", "predict": "SELECT d.name FROM director d WHERE d.age > (SELECT AVG(age) FROM director)", "llm_explanation": "This SQL query selects the names of directors from the 'director' table where their age is greater than the average age of all directors. The subquery (SELECT AVG(age) FROM director) calculates the average age of directors, and the main query filters out those directors whose age exceeds this average.", "gold_exec_result": "[('DeSean Jackson',), ('Hank Baskett',), ('Greg Lewis',), ('Correll Buckhalter',)]", "predict_exec_result": "[('DeSean Jackson',), ('Hank Baskett',), ('Greg Lewis',), ('Correll Buckhalter',)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Find the the name of the oldest director.", "query": "SELECT name FROM director ORDER BY age DESC LIMIT 1", "predict": "SELECT d.name FROM director d ORDER BY d.age DESC LIMIT 1;", "llm_explanation": "This SQL query selects the name of the director from the 'director' table, orders the results by age in descending order (oldest first), and limits the result to just the first row, effectively finding the name of the oldest director.", "gold_exec_result": "[('Hank Baskett',)]", "predict_exec_result": "[('Hank Baskett',)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "How many channels have the word 'bbc' in their internet link?", "query": "SELECT count(*) FROM channel WHERE internet LIKE \"%bbc%\"", "predict": "SELECT COUNT(*) FROM channel WHERE internet LIKE '%bbc%';", "llm_explanation": "This SQL query counts the number of rows in the 'channel' table where the 'internet' column contains the substring 'bbc'. The 'LIKE' operator is used with the pattern '%bbc%', which matches any string that includes 'bbc' anywhere within it. The 'COUNT(*)' function then returns the total number of such rows.", "gold_exec_result": "[(4,)]", "predict_exec_result": "[(4,)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "How many different digital terrestrial channels are there?", "query": "SELECT count(DISTINCT Digital_terrestrial_channel) FROM channel", "predict": "SELECT COUNT(DISTINCT `digital terrestrial channel`) FROM `channel`;", "llm_explanation": "This SQL query counts the number of unique values in the 'digital terrestrial channel' column from the 'channel' table. The DISTINCT keyword ensures that only unique values are counted, providing the total number of different digital terrestrial channels.", "gold_exec_result": "[(12,)]", "predict_exec_result": "no such column: digital terrestrial channel", "exec_match": false}
{"db_id": "bbc_channels", "question": "List all program titles in the order of starting year. List the most recent one first.", "query": "SELECT title FROM program ORDER BY start_year DESC", "predict": "SELECT title FROM program ORDER BY start_year DESC;", "llm_explanation": "This SQL query selects the 'title' column from the 'program' table and orders the results by the 'start_year' column in descending order, ensuring that the most recent programs are listed first. The 'DESC' keyword is used to sort the years from newest to oldest.", "gold_exec_result": "[('Carnival',), ('Othello',), ('The Leopard',), ('Cyrano de Bergerac',), ('Caesar III: An Empire Without End',), ('Dracula',), ('Another Country',), ('The Angry Brigade',)]", "predict_exec_result": "[('Carnival',), ('Othello',), ('The Leopard',), ('Cyrano de Bergerac',), ('Caesar III: An Empire Without End',), ('Dracula',), ('Another Country',), ('The Angry Brigade',)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Which director is in charge of the most programs?", "query": "SELECT t2.name FROM program AS t1 JOIN director AS t2 ON t1.director_id  =  t2.director_id GROUP BY t1.director_id ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT d.name, COUNT(p.program_id) AS program_count FROM director d JOIN program p ON d.director_id = p.director_id GROUP BY d.director_id ORDER BY program_count DESC LIMIT 1", "llm_explanation": "This SQL query joins the 'director' and 'program' tables on the 'director_id' column, counts the number of programs each director is in charge of, and then selects the director with the highest count. The 'GROUP BY' clause groups the results by director, and the 'ORDER BY' clause sorts them in descending order by the count of programs. The 'LIMIT 1' clause ensures that only the top director is returned.", "gold_exec_result": "[('Greg Lewis',)]", "predict_exec_result": "[('Greg Lewis', 2)]", "exec_match": false}
{"db_id": "bbc_channels", "question": "Find the name and age of the director who is in charge of the most programs?", "query": "SELECT t2.name ,  t2.age FROM program AS t1 JOIN director AS t2 ON t1.director_id  =  t2.director_id GROUP BY t1.director_id ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT d.name, d.age FROM director d JOIN program p ON d.director_id = p.director_id GROUP BY d.director_id ORDER BY COUNT(p.program_id) DESC LIMIT 1", "llm_explanation": "This SQL query joins the 'director' and 'program' tables on the 'director_id' column. It groups the results by 'director_id' and orders them by the count of 'program_id' in descending order. The 'LIMIT 1' clause ensures that only the director with the most programs is selected. The query returns the name and age of this director.", "gold_exec_result": "[('Greg Lewis', 52)]", "predict_exec_result": "[('Greg Lewis', 52)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Return the title of the program that began most recently.", "query": "SELECT title FROM program ORDER BY start_year DESC LIMIT 1", "predict": "SELECT title FROM program ORDER BY start_year DESC LIMIT 1", "llm_explanation": "This SQL query retrieves the title of the program with the most recent start year. It sorts the programs in descending order based on the start_year column and limits the result to the top 1 entry, ensuring that the program that began most recently is selected.", "gold_exec_result": "[('Carnival',)]", "predict_exec_result": "[('Carnival',)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Find the name and website link of the channels that have more than one program.", "query": "SELECT t1.name ,  t1.internet FROM channel AS t1 JOIN program AS t2 ON t1.channel_id  =  t2.channel_id GROUP BY t1.channel_id HAVING count(*)  >  1", "predict": "SELECT c.name, c.internet FROM channel c JOIN program p ON c.channel_id = p.channel_id GROUP BY c.channel_id HAVING COUNT(p.program_id) > 1", "llm_explanation": "This SQL query selects the name and internet link from the 'channel' table. It joins the 'channel' table with the 'program' table on the 'channel_id' column. The GROUP BY clause groups the results by 'channel_id', and the HAVING clause filters the groups to include only those with more than one program, as indicated by COUNT(p.program_id) > 1.", "gold_exec_result": "[('ITV2', 'itv.com'), ('Sky1', 'sky.com'), ('Dave', 'dave.uktv.co.uk')]", "predict_exec_result": "[('ITV2', 'itv.com'), ('Sky1', 'sky.com'), ('Dave', 'dave.uktv.co.uk')]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Find the number of programs for each channel. Return the name of each channel as well.", "query": "SELECT t1.name ,  count(*) FROM channel AS t1 JOIN program AS t2 ON t1.channel_id  =  t2.channel_id GROUP BY t1.channel_id", "predict": "SELECT c.name, COUNT(p.program_id) AS num_programs FROM channel c JOIN program p ON c.channel_id = p.channel_id GROUP BY c.channel_id", "llm_explanation": "This SQL query joins the 'channel' and 'program' tables on the 'channel_id' column to count the number of programs for each channel. The 'SELECT' statement retrieves the channel name and the count of program IDs, aliased as 'num_programs'. The 'GROUP BY' clause ensures the count is aggregated per channel.", "gold_exec_result": "[('BBC Two', 1), ('ITV2', 2), ('Sky1', 2), ('Dave', 3)]", "predict_exec_result": "[('BBC Two', 1), ('ITV2', 2), ('Sky1', 2), ('Dave', 3)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Find the number of channels that do not run any program.", "query": "SELECT count(*) FROM channel WHERE channel_id NOT IN (SELECT channel_id FROM program)", "predict": "SELECT COUNT(*) FROM channel WHERE channel.id NOT IN (SELECT DISTINCT channel_id FROM program)", "llm_explanation": "This SQL query counts the number of channels that do not run any program. It first selects channels from the 'channel' table and then uses a subquery to exclude those channels that have at least one program associated with them in the 'program' table. The subquery selects distinct 'channel_id' from the 'program' table, ensuring that any channel with a program is excluded from the main query's count.", "gold_exec_result": "[(10,)]", "predict_exec_result": "no such column: channel.id", "exec_match": false}
{"db_id": "bbc_channels", "question": "What is the name of the director who is in the \"Dracula\" program?", "query": "SELECT t2.name FROM program AS t1 JOIN director AS t2 ON t1.director_id  =  t2.director_id WHERE t1.title  =  'Dracula'", "predict": "SELECT d.name FROM director d JOIN program p ON d.director_id = p.director_id WHERE p.title = 'Dracula'", "llm_explanation": "This SQL query retrieves the name of the director associated with the program titled 'Dracula'. It joins the 'director' and 'program' tables on the 'director_id' column, ensuring the correct director is linked to the program. The WHERE clause filters the results to only include the program with the title 'Dracula'.", "gold_exec_result": "[('Hank Baskett',)]", "predict_exec_result": "[('Hank Baskett',)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Find the name and internet web of the channel that is directed by the most directors.", "query": "SELECT t1.name ,  t1.internet FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id GROUP BY t1.channel_id ORDER BY count(*) DESC LIMIT 1", "predict": "SELECT c.name, c.internet FROM channel c JOIN director_admin da ON c.channel_id = da.channel_id GROUP BY c.channel_id ORDER BY COUNT(da.director_id) DESC LIMIT 1", "llm_explanation": "This SQL query joins the 'channel' table with the 'director_admin' table on the 'channel_id' column. It groups the results by 'channel_id' and orders them by the count of 'director_id' in descending order. The 'LIMIT 1' clause ensures that only the channel with the most directors is selected. The query returns the name and internet web of this channel.", "gold_exec_result": "[('Dave', 'dave.uktv.co.uk')]", "predict_exec_result": "[('Dave', 'dave.uktv.co.uk')]", "exec_match": true}
{"db_id": "bbc_channels", "question": "Find the name of the directors whose age is between 30 and 60.", "query": "SELECT name FROM director WHERE age BETWEEN 30 AND 60", "predict": "SELECT name FROM director WHERE age BETWEEN 30 AND 60;", "llm_explanation": "This SQL query selects the 'name' column from the 'director' table where the 'age' column values are between 30 and 60. The 'director' table is identified by its index (1) in the 'table_names' list. The 'name' and 'age' columns are identified by their respective indices (8 and 9) in the 'column_names' list. The 'BETWEEN' operator is used to filter the age range.", "gold_exec_result": "[('DeSean Jackson',), ('Greg Lewis',), ('Brent Celek',), ('Correll Buckhalter',), ('Reggie Brown',), ('Brian Westbrook',), ('Jason Avant',), ('Kevin Curtis',), ('L.J. Smith',)]", "predict_exec_result": "[('DeSean Jackson',), ('Greg Lewis',), ('Brent Celek',), ('Correll Buckhalter',), ('Reggie Brown',), ('Brian Westbrook',), ('Jason Avant',), ('Kevin Curtis',), ('L.J. Smith',)]", "exec_match": true}
{"db_id": "bbc_channels", "question": "give me the name of channels that have both a director younger than 40 and a director older than 60.", "query": "SELECT t1.name FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id JOIN director AS t3 ON t2.director_id  =  t3.director_id WHERE t3.age  <  40 INTERSECT SELECT t1.name FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id JOIN director AS t3 ON t2.director_id  =  t3.director_id WHERE t3.age  >  60", "predict": "SELECT DISTINCT c.name FROM channel c JOIN director d1 ON c.channel_id = d1.channel_id WHERE d1.age < 40 INTERSECT SELECT DISTINCT c.name FROM channel c JOIN director d2 ON c.channel_id = d2.channel_id WHERE d2.age > 60", "llm_explanation": "This SQL query retrieves the names of channels that have both a director younger than 40 and a director older than 60. It uses two subqueries joined by INTERSECT. The first subquery selects channels with directors younger than 40, and the second selects channels with directors older than 60. The INTERSECT operation ensures only channels present in both subqueries are included in the final result.", "gold_exec_result": "[]", "predict_exec_result": "no such column: d2.channel_id", "exec_match": false}
{"db_id": "bbc_channels", "question": "Find the id and name of the channel that is not directed by Hank Baskett.", "query": "SELECT t1.name ,  t1.channel_id FROM channel AS t1 JOIN director_admin AS t2 ON t1.channel_id  =  t2.channel_id JOIN director AS t3 ON t2.director_id  =  t3.director_id WHERE t3.name != \"Hank Baskett\"", "predict": "SELECT c.channel_id, c.name FROM channel c LEFT JOIN director d ON c.channel_id = d.channel_id WHERE d.name IS NOT 'Hank Baskett' OR d.name IS NULL", "llm_explanation": "This SQL query selects the 'channel_id' and 'name' from the 'channel' table. It uses a LEFT JOIN with the 'director' table to find channels associated with directors. The WHERE clause filters out channels directed by 'Hank Baskett' by checking if the director's name is not 'Hank Baskett' or if there is no director assigned (NULL). This ensures only channels not directed by Hank Baskett are included in the results.", "gold_exec_result": "[('Dave', 14), ('Dave', 14), ('ITV2', 7), ('Dave', 14), ('ITV2', 7)]", "predict_exec_result": "no such column: d.channel_id", "exec_match": false}
{"db_id": "tv_shows", "question": "How many radios are there?", "query": "SELECT count(*) FROM radio", "predict": "SELECT COUNT(*) FROM `radio`;", "llm_explanation": "To find the total number of radios, we use the COUNT(*) function which counts all rows in the specified table. Here, the table of interest is 'radio'. The query will return the total count of rows in the 'radio' table, which corresponds to the total number of radios.", "gold_exec_result": "[(7,)]", "predict_exec_result": "[(7,)]", "exec_match": true}
{"db_id": "tv_shows", "question": "List the transmitters of radios in ascending order of erp kw .", "query": "select transmitter from radio order by erp_kw asc", "predict": "SELECT transmitter FROM radio ORDER BY erp_kw ASC;", "llm_explanation": "The SQL query selects the 'transmitter' column from the 'radio' table and orders the results in ascending order based on the 'erp_kw' column. This ensures that the transmitters are listed from the lowest to the highest ERP (Effective Radiated Power) in kilowatts.", "gold_exec_result": "[('Mount Leinster',), ('Three Rock',), ('Cairn Hill',), ('Maghera',), ('Mullaghanish',), ('Clermont Carn',), ('Kippure',)]", "predict_exec_result": "[('Mount Leinster',), ('Three Rock',), ('Cairn Hill',), ('Maghera',), ('Mullaghanish',), ('Clermont Carn',), ('Kippure',)]", "exec_match": true}
{"db_id": "tv_shows", "question": "What are the names and original air dates of tv shows?", "query": "SELECT tv_show_name ,  Original_Airdate FROM tv_show", "predict": "SELECT tv_show_name, Original_Airdate FROM tv_show;", "llm_explanation": "The query selects the 'tv_show_name' and 'Original_Airdate' columns from the 'tv show' table. This directly answers the question by retrieving the names and original air dates of TV shows. The schema indicates that the 'tv show' table contains these relevant columns, making the query straightforward and efficient.", "gold_exec_result": "[('Peace and Quiet', 'September17,1988'), (\"Box O' Fun\", 'September24,1988'), ('Nighty Nightmare', 'October1,1988'), ('Fraidy Cat', 'October8,1988'), (\"Garfield's Moving Experience\", 'October15,1988'), ('Identity Crisis', 'October22,1988'), ('Weighty Problem', 'October29,1988'), ('Cabin Fever', 'November5,1988'), ('The Binky Show', 'November12,1988'), ('Magic Mutt', 'November19,1988'), ('Best of Breed', 'November26,1988'), ('Caped Avenger', 'December3,1988')]", "predict_exec_result": "[('Peace and Quiet', 'September17,1988'), (\"Box O' Fun\", 'September24,1988'), ('Nighty Nightmare', 'October1,1988'), ('Fraidy Cat', 'October8,1988'), (\"Garfield's Moving Experience\", 'October15,1988'), ('Identity Crisis', 'October22,1988'), ('Weighty Problem', 'October29,1988'), ('Cabin Fever', 'November5,1988'), ('The Binky Show', 'November12,1988'), ('Magic Mutt', 'November19,1988'), ('Best of Breed', 'November26,1988'), ('Caped Avenger', 'December3,1988')]", "exec_match": true}
{"db_id": "tv_shows", "question": "List the station names of city channels whose affiliation is not \"ABC\".", "query": "SELECT Station_name FROM city_channel WHERE Affiliation != \"ABC\"", "predict": "SELECT `station name` FROM `city channel` WHERE `affiliation` != 'ABC'", "llm_explanation": "This SQL query selects the column 'station name' from the table 'city channel'. The WHERE clause filters the rows to include only those where the 'affiliation' column is not equal to 'ABC'. This ensures that the list of station names returned are those of city channels whose affiliation is not 'ABC'.", "gold_exec_result": "[('KZKC-LP',), ('KZSD-LP',), ('KZKS-LP',), ('KZCO-LP',), ('KZFC-LP',), ('WPTV',)]", "predict_exec_result": "no such table: city channel", "exec_match": false}
{"db_id": "tv_shows", "question": "Show the transmitters of radios whose ERP is bigger than 150 or smaller than 30.", "query": "SELECT Transmitter FROM radio WHERE ERP_kW  >  150 OR ERP_kW  <  30", "predict": "SELECT transmitter FROM radio WHERE erp_kw > 150 OR erp_kw < 30;", "llm_explanation": "This SQL query selects the 'transmitter' column from the 'radio' table where the 'erp_kw' (Effective Radiated Power in kilowatts) is either greater than 150 or less than 30. The query uses the WHERE clause to filter the records based on the specified conditions, ensuring that only transmitters with ERP values outside the 30 to 150 range are included in the results.", "gold_exec_result": "[('Cairn Hill',), ('Clermont Carn',), ('Kippure',), ('Maghera',), ('Mount Leinster',), ('Mullaghanish',), ('Three Rock',)]", "predict_exec_result": "[('Cairn Hill',), ('Clermont Carn',), ('Kippure',), ('Maghera',), ('Mount Leinster',), ('Mullaghanish',), ('Three Rock',)]", "exec_match": true}
{"db_id": "tv_shows", "question": "What is the transmitter of the radio with the largest ERP_kW?", "query": "SELECT Transmitter FROM radio ORDER BY ERP_kW DESC LIMIT 1", "predict": "SELECT transmitter FROM radio ORDER BY ERP_kW DESC LIMIT 1;", "llm_explanation": "This SQL query selects the 'transmitter' column from the 'radio' table. It orders the results in descending order based on the 'ERP_kW' column, which represents the Effective Radiated Power in kilowatts. The 'LIMIT 1' clause ensures that only the top result (the radio with the largest ERP_kW) is returned.", "gold_exec_result": "[('Clermont Carn',)]", "predict_exec_result": "[('Clermont Carn',)]", "exec_match": true}
{"db_id": "tv_shows", "question": "What is the average ERP across all radios?", "query": "SELECT avg(ERP_kW) FROM radio", "predict": "SELECT AVG(erp_kw) AS average_erp FROM radio", "llm_explanation": "The query calculates the average value of the 'erp_kw' column from the 'radio' table. The 'erp_kw' column represents the ERP (Effective Radiated Power) in kilowatts for each radio. The AVG function is used to compute the average of this column across all rows in the 'radio' table, and the result is labeled as 'average_erp'.", "gold_exec_result": "[(75.5,)]", "predict_exec_result": "[(75.5,)]", "exec_match": true}
{"db_id": "tv_shows", "question": "Show the different affiliations of city channels and the number of city channels with each affiliation.", "query": "SELECT Affiliation ,  COUNT(*) FROM city_channel GROUP BY Affiliation", "predict": "SELECT affiliation, COUNT(*) AS num_city_channels FROM `city channel` GROUP BY affiliation;", "llm_explanation": "This SQL query selects the 'affiliation' column from the 'city channel' table and counts the number of occurrences for each unique affiliation using COUNT(*). The GROUP BY clause is used to group the results by the 'affiliation' column, ensuring that the count is calculated for each distinct affiliation. This provides a list of different affiliations and the number of city channels associated with each affiliation.", "gold_exec_result": "[('ABC', 8), ('Azteca Am\u00e9rica', 5), ('NBC', 1)]", "predict_exec_result": "no such table: city channel", "exec_match": false}
{"db_id": "tv_shows", "question": "Please show the most common affiliation for city channels.", "query": "SELECT Affiliation FROM city_channel GROUP BY Affiliation ORDER BY COUNT(*) DESC LIMIT 1", "predict": "SELECT affiliation, COUNT(*) AS count FROM `city channel` GROUP BY affiliation ORDER BY count DESC LIMIT 1;", "llm_explanation": "This SQL query selects the 'affiliation' column from the 'city channel' table and counts the occurrences of each affiliation. It groups the results by 'affiliation' and orders them in descending order based on the count. The 'LIMIT 1' clause ensures that only the most common affiliation is returned.", "gold_exec_result": "[('ABC',)]", "predict_exec_result": "no such table: city channel", "exec_match": false}
{"db_id": "tv_shows", "question": "List the affiliations shared by more than three city channels.", "query": "SELECT Affiliation FROM city_channel GROUP BY Affiliation HAVING COUNT(*)  >  3", "predict": "SELECT affiliation FROM city_channel GROUP BY affiliation HAVING COUNT(DISTINCT city) > 3;", "llm_explanation": "This SQL query selects the 'affiliation' column from the 'city_channel' table. It groups the results by 'affiliation' and uses the HAVING clause to filter out affiliations that are shared by more than three distinct cities. The COUNT(DISTINCT city) function counts the unique cities associated with each affiliation, ensuring that only those with more than three cities are listed.", "gold_exec_result": "[('ABC',), ('Azteca Am\u00e9rica',)]", "predict_exec_result": "[('ABC',), ('Azteca Am\u00e9rica',)]", "exec_match": true}
{"db_id": "tv_shows", "question": "Show the cities and station names of city channels in ascending alphabetical order of station name.", "query": "SELECT City ,  Station_name FROM city_channel ORDER BY Station_name ASC", "predict": "SELECT city, station_name FROM city_channel ORDER BY station_name ASC", "llm_explanation": "This SQL query selects the 'city' and 'station_name' columns from the 'city_channel' table. The ORDER BY clause is used to sort the results in ascending alphabetical order based on the 'station_name' column. This ensures that the output lists cities and station names in the desired order.", "gold_exec_result": "[('Bakersfield, California', 'KERO-TV'), ('San Diego', 'KGTV'), ('Denver', 'KMGH-TV'), ('Phoenix', 'KNXV-TV'), ('Denver', 'KZCO-LP'), ('Fort Collins, Colorado', 'KZFC-LP'), ('Bakersfield, California', 'KZKC-LP'), ('Colorado Springs, Colorado', 'KZKS-LP'), ('San Diego', 'KZSD-LP'), ('Tampa \u2013 St. Petersburg', 'WFTS-TV'), ('Baltimore', 'WMAR-TV'), ('West Palm Beach', 'WPTV'), ('Indianapolis', 'WRTV'), ('Detroit', 'WXYZ-TV')]", "predict_exec_result": "[('Bakersfield, California', 'KERO-TV'), ('San Diego', 'KGTV'), ('Denver', 'KMGH-TV'), ('Phoenix', 'KNXV-TV'), ('Denver', 'KZCO-LP'), ('Fort Collins, Colorado', 'KZFC-LP'), ('Bakersfield, California', 'KZKC-LP'), ('Colorado Springs, Colorado', 'KZKS-LP'), ('San Diego', 'KZSD-LP'), ('Tampa \u2013 St. Petersburg', 'WFTS-TV'), ('Baltimore', 'WMAR-TV'), ('West Palm Beach', 'WPTV'), ('Indianapolis', 'WRTV'), ('Detroit', 'WXYZ-TV')]", "exec_match": true}
{"db_id": "tv_shows", "question": "Show the transmitters of radios and the cities of the channels they are associated with.", "query": "SELECT T3.Transmitter ,  T2.City FROM city_channel_radio AS T1 JOIN city_channel AS T2 ON T1.City_channel_ID  =  T2.ID JOIN radio AS T3 ON T1.Radio_ID  =  T3.Radio_ID", "predict": "SELECT r.transmitter, c.city FROM radio r JOIN city_channel_radio cr ON r.radio_id = cr.radio_id JOIN city_channel c ON cr.city_channel_id = c.city_channel_id;", "llm_explanation": "This SQL query joins three tables: 'radio', 'city_channel_radio', and 'city_channel'. It selects the 'transmitter' column from the 'radio' table and the 'city' column from the 'city_channel' table. The join conditions ensure that we only get transmitters for radios that are associated with specific city channels, linking 'radio_id' in 'radio' and 'city_channel_radio', and 'city_channel_id' in 'city_channel_radio' and 'city_channel'.", "gold_exec_result": "[('Cairn Hill', 'Phoenix'), ('Clermont Carn', 'Bakersfield, California'), ('Kippure', 'Bakersfield, California'), ('Maghera', 'San Diego'), ('Mullaghanish', 'San Diego'), ('Cairn Hill', 'Colorado Springs, Colorado'), ('Mount Leinster', 'Denver'), ('Kippure', 'Denver'), ('Cairn Hill', 'Tampa \u2013 St. Petersburg'), ('Clermont Carn', 'Indianapolis')]", "predict_exec_result": "no such column: c.city_channel_id", "exec_match": false}
{"db_id": "tv_shows", "question": "Show the transmitters of radios and the station names of the channels they are associated with in descending order of the ERP of the radios.", "query": "SELECT T3.Transmitter ,  T2.Station_name FROM city_channel_radio AS T1 JOIN city_channel AS T2 ON T1.City_channel_ID  =  T2.ID JOIN radio AS T3 ON T1.Radio_ID  =  T3.Radio_ID ORDER BY T3.ERP_kW DESC", "predict": "SELECT r.transmitter, c.station_name FROM radio r JOIN city_channel c ON r.radio_id = c.radio_id ORDER BY r.erp_kw DESC", "llm_explanation": "The query selects the transmitter from the 'radio' table and the station name from the 'city channel' table. It joins these tables on the 'radio_id' column to associate transmitters with their respective station names. The results are ordered in descending order based on the 'erp_kw' column from the 'radio' table, which represents the ERP (Effective Radiated Power) of the radios.", "gold_exec_result": "[('Clermont Carn', 'KERO-TV'), ('Kippure', 'KZKC-LP'), ('Kippure', 'KZCO-LP'), ('Clermont Carn', 'WRTV'), ('Maghera', 'KGTV'), ('Mullaghanish', 'KGTV'), ('Cairn Hill', 'KNXV-TV'), ('Cairn Hill', 'KZKS-LP'), ('Cairn Hill', 'WFTS-TV'), ('Mount Leinster', 'KMGH-TV')]", "predict_exec_result": "no such column: c.radio_id", "exec_match": false}
{"db_id": "tv_shows", "question": "Show the transmitters of the radios and the number of city channels they are associated with.", "query": "SELECT T2.Transmitter ,  COUNT(*) FROM city_channel_radio AS T1 JOIN radio AS T2 ON T1.Radio_ID  =  T2.Radio_ID GROUP BY T2.Transmitter", "predict": "SELECT r.transmitter, COUNT(ccr.city_channel_id) AS num_city_channels FROM radio r JOIN city_channel_radio ccr ON r.radio_id = ccr.radio_id GROUP BY r.transmitter", "llm_explanation": "This SQL query joins the 'radio' table with the 'city_channel_radio' table on the 'radio_id' column to associate transmitters with city channels. It then groups the results by the 'transmitter' column and counts the number of city channels associated with each transmitter. The result shows each transmitter and the count of city channels it is associated with.", "gold_exec_result": "[('Cairn Hill', 3), ('Clermont Carn', 2), ('Kippure', 2), ('Maghera', 1), ('Mount Leinster', 1), ('Mullaghanish', 1)]", "predict_exec_result": "[('Cairn Hill', 3), ('Clermont Carn', 2), ('Kippure', 2), ('Maghera', 1), ('Mount Leinster', 1), ('Mullaghanish', 1)]", "exec_match": true}
